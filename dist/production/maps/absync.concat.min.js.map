{"version":3,"sources":["_absync.module.js","absync.js","absync.concat.js","cache-service.js","configuration.js","noop-log.js","uncached.js"],"names":["angular","module","getAbsyncProvider","$injector","$provide","absyncCache","AbsyncProvider","self","this","__injector","__provide","__absyncCache","__ioSocket","__registerLater","__listeners","__collections","__entities","debug","undefined","$inject","provider","prototype","configure","configuration","constructor","name","Error","socket","isSocket","io","Socket","length","forEach","__registerListener","bind","collection","entity","disconnect","disconnectSocket","listener","unregister","push","__registerEntityEventListener","eventName","callback","provideService","injector","instance","instantiate","service","sync","teardown","serviceDefinition","on","off","listenerIndex","splice","removeListener","$get","getServiceConstructor","CacheService","$http","$log","$q","$rootScope","absync","absyncNoopLog","absyncUncachedFilter","_injector","_injectorHasModel","has","model","_model","get","serializeModel","serialize","serializationNoop","deserializeModel","deserialize","entityCache","collectionName","__lookup","__entityCacheRaw","enableRequestCache","__requestCache","allowBrowserCache","merge","extend","request","__uncached","httpInterface","logInterface","scope","q","logPrefix","toLocaleUpperCase","forceEarlyCacheUpdate","throwFailures","serializer","deserializer","filter","__onEntityOnWebsocketBound","__onEntityOnWebsocket","__onCollectionOnWebsocketBound","__onCollectionOnWebsocket","__onEntityReceivedBound","__onEntityReceived","__onCollectionReceivedBound","__onCollectionReceived","entityName","$on","info","afterEntityStored","returnResult","serverResponse","data","rawEntity","newEntity","__updateCacheWithEntity","onEntityStorageFailure","error","$emit","message","$broadcast","__onDataAvailable","rawData","deserializeCollectionEntry","entityToCache","id","Array","isArray","cache","deserialized","event","args","_entityReceived","collectionUri","entityUri","directResponse","when","Object","keys","hasOwnProperty","__cacheMaintain","__removeEntityFromCache","ensureLoaded","then","read","addEntityToCache","entityReceived","_collectionReceived","forceReload","onCollectionReceived","onCollectionRetrievalFailure","onSingleEntityReceived","onSingleEntityRetrievalFailure","__loading","seed","phantom","timeout","Number","POSITIVE_INFINITY","resolve","reject","removeTimeout","setTimeout","clearTimeout","onEntityRetrieved","onEntityRetrievalFailure","entityIndex","__requestEntity","removeRequestFromCache","requestUri","update","reduced","reduceComplex","serialized","wrappedEntity","put","post","patch","create","onEntityDeleted","entityId","onEntityDeletionFailed","operation","emit","updated","copyFrom","found","noop","targetEntity","cacheEntry","lookupTableById","lookupTable","arrayInsteadOfObject","result","propertyName","populateComplex","options","mapElementToPromise","element","index","onComplexRetrieved","complex","crossLink","force","crossLinkProperty","idIndex","indexOf","lookupIndex","lookupEntity","warn","promises","map","all","reset","constant","AbsyncServiceConfigurationFactory","AbsyncServiceConfiguration","_modelName","toLowerCase","uncachedFilterProvider","uncachedFilter","url","delimiter","discriminator","Date","getTime"],"mappings":"CAAC,WACD,YAGAA,SAAQC,OAAQ,gBCJf,WACD,YAwBA,SAASC,GAAmBC,EAAWC,EAAUC,GAChD,MAAO,IAAIC,GAAgBH,EAAWC,EAAUC,GAUjD,QAASC,GAAgBH,EAAWC,EAAUC,GAC7C,GAAIE,GAAOC,IAEXD,GAAKE,WAAgBN,EAErBI,EAAKG,UAAgBN,EAErBG,EAAKI,cAAgBN,EAGrBE,EAAKK,WAAa,KAIlBL,EAAKM,mBAELN,EAAKO,eAKLP,EAAKQ,iBAKLR,EAAKS,cAGLT,EAAKU,MAAQC,OC9CdhB,EAAkBiB,SAAW,YAAa,WAAY,eDLtDnB,QACEC,OAAQ,UACRmB,SAAU,SAAUlB,GA2DtBI,EAAee,UAAUC,UAAY,SAAmCC,GACvE,GAAIhB,GAAOC,IAEX,IAAuC,WAAnCe,EAAcC,YAAYC,KAC7B,KAAM,IAAIC,OAAO,yGAGlB,IAAoC,mBAAzBH,GAAcI,OAAyB,CACjD,GAAIA,GAAWJ,EAAcI,OAEzBC,EAAyB,mBAAPC,KAAsBA,GAAGC,QAAUH,YAAkBE,IAAGC,MAE9E,IAAqB,kBAAVH,GAEVpB,EAAKK,WAAa,GAAIe,OAEhB,CAAA,IAAIC,EAKV,KAAM,IAAIF,OAAO,4FAHjBnB,GAAKK,WAAae,EAQfpB,EAAKM,gBAAgBkB,SACxB/B,QAAQgC,QAASzB,EAAKM,gBAAiBN,EAAK0B,mBAAmBC,KAAM3B,IACrEA,EAAKM,oBAI4B,mBAAxBU,GAAcN,QACxBV,EAAKU,MAAQM,EAAcN,QAAS,GAGjCV,EAAKU,QACRjB,QAAQgC,QAASzB,EAAKQ,cAAe,SAA0BoB,GAC9DA,EAAWZ,cAAcN,OAAQ,IAElCjB,QAAQgC,QAASzB,EAAKS,WAAY,SAA0BoB,GAC3DA,EAAOb,cAAcN,OAAQ,MAShCX,EAAee,UAAUgB,WAAa,SAAoCC,GACzE,GAAI/B,GAAOC,IAEX8B,GAAmBA,IAAoB,EAEvCtC,QAAQgC,QAASzB,EAAKO,YAAa,SAA6ByB,GAC/DA,EAASC,mBACFD,GAASC,WAChBjC,EAAKM,gBAAgB4B,KAAMF,KAG5BhC,EAAKO,eAEDwB,IACH/B,EAAKK,WAAWyB,aAChB9B,EAAKK,WAAa,OASpBN,EAAee,UAAUY,mBAAqB,SAA0CM,GACvF,GAAIhC,GAAOC,IAGXD,GAAKO,YAAY2B,KAAMF,GAGvBA,EAASC,WAAajC,EAAKmC,8BAA+BH,EAASI,UAAWJ,EAASK,WASxFtC,EAAee,UAAUc,WAAa,SAAoCV,EAAMF,GAC/E,GAAIhB,GAAOC,IAIX,IAAID,EAAKQ,cAAeU,GACvB,KAAM,IAAIC,OAAO,+BAAiCD,EAAO,iEAE1D,IAAIlB,EAAKS,WAAYS,GACpB,KAAM,IAAIC,OAAO,4BAA8BD,EAAO,mGAavD,IATAF,EAAcN,MAAuC,mBAAxBM,GAAcN,MAAwBV,EAAKU,MAAQM,EAAcN,MAI9FV,EAAKQ,cAAeU,IACnBD,YAAgBjB,EAAKI,cAAec,EAAMF,GAC1CA,cAAgBA,GAGbA,EAAcsB,kBAAmB,EAAQ,CAC5C,IAAKtB,EAAcuB,SAAW,CAC7B,GAAI3C,GAAYH,QAAQ8C,UAAY,KAAM,WAC1CvB,GAAcuB,SAAW3C,EAI1B,MADAI,GAAKQ,cAAeU,GAAOsB,SAAWxB,EAAcuB,SAASE,YAAazC,EAAKQ,cAAeU,GAAOD,aAC9FjB,EAAKQ,cAAeU,GAAOsB,SAKnCxC,EAAKG,UAAUuC,QAASxB,EAAMlB,EAAKQ,cAAeU,GAAOD,cAS1DlB,EAAee,UAAUe,OAAS,SAAgCX,EAAMF,GACvE,GAAIhB,GAAOC,IAIX,IAAID,EAAKS,WAAYS,GACpB,KAAM,IAAIC,OAAO,4BAA8BD,EAAO,8DAEvD,IAAIlB,EAAKQ,cAAeU,GACvB,KAAM,IAAIC,OAAO,+BAAiCD,EAAO,mGAa1D,IATAF,EAAcN,MAAuC,mBAAxBM,GAAcN,MAAwBV,EAAKU,MAAQM,EAAcN,MAI9FV,EAAKS,WAAYS,IAChBD,YAAgBjB,EAAKI,cAAec,EAAMF,GAC1CA,cAAgBA,GAGbA,EAAcsB,kBAAmB,EAAQ,CAC5C,GAAI1C,GAAYH,QAAQ8C,UAAY,KAAM,UAC1C,OAAO3C,GAAU6C,YAAazC,EAAKQ,cAAeU,GAAOD,aAK1DjB,EAAKG,UAAUuC,QAASxB,EAAMlB,EAAKS,WAAYS,GAAOD,cAGvDlB,EAAee,UAAU6B,KAAO,SAA8BzB,EAAMF,GACnE,GAAIhB,GAAOC,IAEX,OAAID,GAAKQ,cAAeU,IAAUlB,EAAKQ,cAAeU,GAAOsB,SACrDxC,EAAKQ,cAAeU,GAAOsB,UAInCxB,EAAcsB,gBAAiB,EAExBtC,EAAK4B,WAAYV,EAAMF,KAO/BjB,EAAee,UAAU8B,SAAW,SAAkCF,GACrE,GAAI1C,GAAOC,KAEP4C,EAAoB7C,EAAKS,WAAYiC,EAAQxB,OAAUlB,EAAKQ,cAAekC,EAAQxB,KACvF,KAAK2B,EACJ,KAAM,IAAI1B,OAAO,4BAA8BuB,EAAQxB,KAAO,wBAG/D,IAAI2B,EAAkB7B,cAAcsB,kBAAmB,EACtD,KAAM,IAAInB,OAAO,gBAAkBuB,EAAQxB,KAAO,6EAG5ClB,GAAKS,WAAYiC,EAAQxB,YACzBlB,GAAKQ,cAAekC,EAAQxB,MAEnCwB,EAAQE,YAWT7C,EAAee,UAAUgC,GAAK,SAA4BV,EAAWC,GACpE,GAAIrC,GAAOC,IAGX,OAAKD,GAAKK,WAeHL,EAAK0B,oBACXU,UAAYA,EACZC,SAAYA,IAfRrC,EAAKM,gBAAgBkB,OAAS,KAE1B,MAIRxB,EAAKM,gBAAgB4B,MACpBE,UAAYA,EACZC,SAAYA,IAEN,OAcTtC,EAAee,UAAUiC,IAAM,SAA6BX,EAAWC,GAGtE,IAAK,GAFDrC,GAAOC,KAEF+C,EAAgB,EAAGA,EAAgBhD,EAAKO,YAAYiB,SAAUwB,EACtE,GAAIhD,EAAKO,YAAayC,GAAgBZ,YAAcA,GAAapC,EAAKO,YAAayC,GAAgBX,WAAaA,EAG/G,MAFArC,GAAKO,YAAY0C,OAAQD,EAAe,OACxChD,GAAKO,YAAayC,GAAgBf,cAYrClC,EAAee,UAAUqB,8BAAgC,SAAqDC,EAAWC,GACxH,GAAIrC,GAAOC,IAMX,OAHAD,GAAKK,WAAWyC,GAAIV,EAAWC,GAGxB,WACNrC,EAAKK,WAAW6C,eAAgBd,EAAWC,KAS7CtC,EAAee,UAAUqC,KAAO,WAC/B,MAAOlD,UE7VP,WACD,YAuBA,SAASmD,GAAuBlC,EAAMF,GAkBrC,QAASqC,GAAcC,EAAO1D,EAAW2D,EAAMC,EAAIC,EAAYC,EAAQC,EAAeC,GACrF,GAAI5D,GAAOC,KAGP4D,EAAoB7C,EAAcuB,UAAY3C,EAC9CkE,EAAoBD,EAAUE,IAAK/C,EAAcgD,MACrD,KAAKF,EACJ,KAAM,IAAI3C,OAAO,4BAA8BD,EAAO,4CAA8CF,EAAcgD,MAAQ,oCAE3H,IAAIC,GAA0C,gBAAxBjD,GAAcgD,MAAuBH,EAAUK,IAAKlD,EAAcgD,OAAUhD,EAAcgD,MAG5GG,EAAmBF,EAAOG,WAAapD,EAAcoD,WAAaC,EAClEC,EAAmBL,EAAOM,aAAevD,EAAcuD,aAAeF,CAG1ErE,GAAKkB,KAAgBA,EACrBlB,EAAKgB,cAAgBA,EAMrBhB,EAAKwE,YAAuBxD,EAAcyD,qBAE1CzE,EAAKwE,YAAYE,YAEjB1E,EAAK2E,iBAAuB,KAG5B3E,EAAK4E,oBAAqB,EAE1B5E,EAAK6E,kBAKL7E,EAAK8E,mBAAsBrF,QAAQsF,OAAStF,QAAQuF,YAEnDrC,MAAU,EAEVsC,SAAU,GACRjE,EAAc8D,mBACjB9E,EAAKkF,WAAoBtB,EAIzB5D,EAAKmF,cAAgB7B,EAErBtD,EAAKoF,aAAgBpE,EAAcN,MAAQ6C,EAAOI,EAElD3D,EAAKqF,MAAgBrE,EAAcqE,OAAS5B,EAE5CzD,EAAKsF,EAAgB9B,EAErBxD,EAAK0D,OAAgBA,EAGrB1D,EAAKuF,UAAY,UAAYrE,EAAKsE,oBAAsB,IAIxDxF,EAAKyF,sBAAwBzE,EAAcyE,wBAAyB,EAGpEzF,EAAK0F,cAAuD,mBAAhC1E,GAAc0E,eAAgC1E,EAAc0E,cAGxF1F,EAAK2F,WAAexB,EACpBnE,EAAK4F,aAAetB,EAGpBtE,EAAK6F,OAAS7E,EAAc6E,OAG5B7F,EAAK8F,2BAAiC9F,EAAK+F,sBAAsBpE,KAAM3B,GACvEA,EAAKgG,+BAAiChG,EAAKiG,0BAA0BtE,KAAM3B,GAC3EA,EAAKkG,wBAAiClG,EAAKmG,mBAAmBxE,KAAM3B,GACpEA,EAAKoG,4BAAiCpG,EAAKqG,uBAAuB1E,KAAM3B,GAKxE0D,EAAOZ,GAAI9B,EAAcsF,WAAYtG,EAAK8F,4BACtC9E,EAAcyD,gBACjBf,EAAOZ,GAAI9B,EAAcyD,eAAgBzE,EAAKgG,gCAK/ChG,EAAKkG,wBAAwBjE,WAAajC,EAAKqF,MAAMkB,IAAKvF,EAAcsF,WACvEtG,EAAKkG,yBACFlF,EAAcyD,iBACjBzE,EAAKoG,4BAA4BnE,WAAajC,EAAKqF,MAAMkB,IAAKvF,EAAcyD,eAC3EzE,EAAKoG,8BAGPpG,EAAKoF,aAAaoB,KAAMxG,EAAKuF,UAAY,6BAwhB1C,QAASkB,GAAmBC,EAAcC,GACzC,GAAI3G,GAAOC,IAKX,KAAKyG,GAAiB1G,EAAKyF,wBAIvBkB,EAAeC,KAAM5F,EAAcsF,YAAe,CACrD,GAAIO,GAAYF,EAAeC,KAAM5F,EAAcsF,WAEnD,IAAItG,EAAKyF,sBAAwB,CAChC,GAAIqB,GAAY9G,EAAK4F,aAAciB,EAGnC,IAFA7G,EAAK+G,wBAAyBD,GAE1BJ,EACH,MAAOI,GAGT,GAAIJ,EACH,MAAOG,IASV,QAASG,GAAwBL,GAChC,GAAI3G,GAAOC,IAOX,IALAD,EAAKoF,aAAa6B,MAAOjH,EAAKuF,UAAY,wCACzCoB,GACD3G,EAAKoF,aAAa6B,MAAON,GACzB3G,EAAKqF,MAAM6B,MAAO,cAAeP,GAE7B3G,EAAK0F,cACR,KAAMiB,GA6cR,MDzwBAtD,GAAazC,SAAW,QAAS,YAAa,OAAQ,KAAM,aAAc,SAAU,gBAAiB,wBC3PrGyC,EAAavC,UAAUiF,sBAAwB,SAA2CoB,GACzF,GAAInH,GAAOC,IACXD,GAAKoF,aAAa1E,MAAOV,EAAKuF,UAAY,kBAAmB4B,GAC7DnH,EAAKqF,MAAM+B,WAAYpG,EAAcsF,WAAYa,EAASnG,EAAcsF,cASzEjD,EAAavC,UAAUmF,0BAA4B,SAA+CkB,GACjG,GAAInH,GAAOC,IACXD,GAAKoF,aAAa1E,MAAOV,EAAKuF,UAAY,sBAAuB4B,GACjEnH,EAAKqF,MAAM+B,WAAYpG,EAAcyD,eAAgB0C,EAASnG,EAAcyD,kBAQ7EpB,EAAavC,UAAUuG,kBAAoB,SAAuCC,GAuBjF,QAASC,GAA4BV,GACpC,GAAIW,GAAgBxH,EAAK4F,aAAciB,EACvC7G,GAAKwE,YAAYtC,KAAMsF,GACnBxH,EAAKwE,YAAYE,WACpB1E,EAAKwE,YAAYE,SAAU8C,EAAcC,IAAOzH,EAAKwE,YAAYhD,OAAS,GA1B5E,GAAIxB,GAAOC,IAEX,IAAIyH,MAAMC,QAAS3H,EAAKwE,aAKvB/E,QAAQgC,QAAS6F,EAAStG,EAAcyD,gBAAkB8C,GAG1DvH,EAAKqF,MAAM+B,WAAY,iBACtB1E,QAAU1C,EACV4H,MAAU5H,EAAKwE,kBAGV,CACN,GAAIqD,GAAe7H,EAAK4F,aAAc0B,EAAStG,EAAcsF,YAC7DtG,GAAK+G,wBAAyBc,GAG/B,MAAO7H,GAAKwE,aAkBbnB,EAAavC,UAAUqF,mBAAqB,SAAwC2B,EAAOC,GAC1F,GAAI/H,GAAkBC,KAClB+H,EAAkBD,CAItB,IAAoC,OAAhC/G,EAAciH,eAAsD,OAA5BjH,EAAckH,UAAqB,CAE9E,GAAIC,IACHzF,QAAU1C,EACV4H,MAAU5H,EAAKwE,YACf3C,OAAUmG,EAOX,OAJAhI,GAAKqF,MAAM+B,WAAY,kBAAmBe,GAC1CnI,EAAKqF,MAAM+B,WAAY,YAAae,GAG7BnI,EAAKsF,EAAE8C,OAMf,MAAKpI,GAAK2E,kBAAqB3E,EAAK2E,iBAAkB3D,EAAcyD,gBAAkBzD,EAAcsF,YAYhG,IAAM+B,OAAOC,KAAMN,GAAkBxG,QAAUwG,EAAgBO,eAAgB,OAClFvI,EAAKoF,aAAaoB,KAAMxG,EAAKuF,UAAY,uDAEzCvF,EAAKwI,gBAAiBxI,EAAK2E,iBAAkB3D,EAAcyD,gBAAkBzD,EAAcsF,YAC1F0B,EACA,UACA,GAEMhI,EAAKyI,wBAAyBT,EAAgBP,MAGrDzH,EAAKoF,aAAa1E,MAAOV,EAAKuF,UAAY,qDAE1CvF,EAAKwI,gBAAiBxI,EAAK2E,iBAAkB3D,EAAcyD,gBAAkBzD,EAAcsF,YAC1F0B,EACA,UACA,GAEMhI,EAAK+G,wBAAyB/G,EAAK4F,aAAcoC,KA1BjDhI,EAAK0I,eACVC,KAAM,WACN,MAAO3I,GAAK4I,KAAMZ,EAAgBP,OAkCtCpE,EAAavC,UAAUuF,uBAAyB,SAA4CyB,EAAOC,GAYlG,QAASc,GAAkBC,GAC1B,GAAIjB,GAAe7H,EAAK4F,aAAckD,EACtC9I,GAAK+G,wBAAyBc,GAb/B,GAAI7H,GAAsBC,KACtB8I,EAAsBhB,CAK1B/H,GAAKwE,YAAYhD,OAAS,EAG1B/B,QAAQgC,QAASsH,EAAqBF,IAavCxF,EAAavC,UAAU4H,aAAe,SAAoCM,GA4CzE,QAASC,GAAsBtC,GAC9B,IAAKA,EAAeC,KAAM5F,EAAcyD,gBACvC,KAAM,IAAItD,OAAO,+FAAiGH,EAAcyD,eAAiB,KAKlJ,OAFAzE,GAAK2E,iBAAmBgC,EAAeC,KACvC5G,EAAKwE,YAAYvB,OAAQ,EAAGjD,EAAKwE,YAAYhD,QACtCxB,EAAKqH,kBAAmBV,EAAeC,MAO/C,QAASsC,GAA8BvC,GAOtC,GANA3G,EAAKoF,aAAa6B,MAAOjH,EAAKuF,UAAY,qDACzCoB,GACD3G,EAAK2E,iBAAmB,KAExB3E,EAAKqF,MAAM6B,MAAO,cAAeP,GAE7B3G,EAAK0F,cACR,KAAMiB,GAQR,QAASwC,GAAwBxC,GAChC,IAAKA,EAAeC,KAAM5F,EAAcsF,YACvC,KAAM,IAAInF,OAAO,+FAAiGH,EAAcsF,WAAa,KAG9ItG,GAAK2E,iBAAmBgC,EAAeC,KACvC5G,EAAKqH,kBAAmBV,EAAeC,MAOxC,QAASwC,GAAgCzC,GAOxC,GANA3G,EAAKoF,aAAa6B,MAAOjH,EAAKuF,UAAY,iDACzCoB,GACD3G,EAAK2E,iBAAmB,KAExB3E,EAAKqF,MAAM6B,MAAO,cAAeP,GAE7B3G,EAAK0F,cACR,KAAMiB,GA9FR,GAAI3G,GAAOC,IAOX,IALA+I,EAAcA,KAAgB,EAC1BA,SACIhJ,GAAKqJ,UAGTrJ,EAAKqJ,UACR,MAAOrJ,GAAKqJ,SAIb,IAAI,OAASrJ,EAAK2E,kBAAoBqE,EAAc,CACnD,GAAKhI,EAAcyD,gBAAmBzD,EAAciH,cAcnDjI,EAAKoF,aAAaoB,KAAMxG,EAAKuF,UAAY,eAAiBvE,EAAcyD,eAAiB,iBACzFzE,EAAKqJ,UAAYrJ,EAAKmF,cACpBjB,IAAKlE,EAAK8E,kBAAkBnC,KAAO3B,EAAciH,cAAgBjI,EAAKkF,WACtElE,EAAciH,gBACdU,KAAMM,EAAsBC,OAlBqC,CACnE,IAAIlI,EAAcsF,aAActF,EAAckH,UAS7C,MAAOlI,GAAKsF,EAAE8C,QARdpI,GAAKqJ,UAAYrJ,EAAKmF,cACpBjB,IAAKlE,EAAK8E,kBAAkBnC,KAAO3B,EAAckH,UAAYlI,EAAKkF,WAClElE,EAAckH,YACdS,KAAMQ,EAAwBC,GAgBlC,MAAOpJ,GAAKqJ,UAGb,MAAOrJ,GAAKsF,EAAE8C,KAAMpI,EAAKwE,cAoE1BnB,EAAavC,UAAUwI,KAAO,SAA4B1B,GACzD,GAAI5H,GAAoBC,IAGxB,OAFAD,GAAK2E,iBAAmBiD,EAEjB5H,EAAKqH,kBAAmBrH,EAAK2E,mBAYrCtB,EAAavC,UAAUyI,QAAU,SAA+B1H,EAAQ2H,GACvE,GAAIxJ,GAAOC,IAEX,OAAID,GAAK+D,IAAKlC,EAAO4F,IACbzH,EAAK4I,KAAM/G,EAAO4F,KAG1B+B,EAAsB,OAAZA,EAAmBC,OAAOC,kBAAoBF,EACxDA,EAA6B,mBAAZA,GAA0B,KAAOA,EAG3CxJ,EAAKsF,EAAE8C,KAAMpI,EAAKmG,mBAAoB,KAAMtE,IACjD8G,KAAM,WACN,MAAO,IAAI3I,GAAKsF,EAAG,SAAmBqE,EAASC,GAE9C,GAAgB,OAAZJ,EAEH,MAAOG,GAAS9H,EAGjB,IAAIgI,GAAiB,KACjB3G,EAAiB,IAEjBsG,GAAUC,OAAOC,oBACpBG,EAAgBC,WAAY,WACvB5G,GACHA,IAGD0G,EAAQ,GAAIzI,OAAO,uCACjBqI,IAGJtG,EAAiBlD,EAAKqF,MAAMkB,IAAK,gBAAiB,SAA0BuB,EAAOC,GAC9EA,EAAKlG,OAAO4F,KAAO5F,EAAO4F,KAC7BvE,IACA6G,aAAcF,GAEd3G,EAAiB,KACjB2G,EAAiB,KAEjBF,EAAS5B,EAAKlG,iBAWpBwB,EAAavC,UAAU6B,KAAO,WAC7B,GAAI3C,GAAOC,IAIX,OAFAD,GAAK2E,iBAAmB,KAEjB3E,EAAK0I,cAAc,IAQ3BrF,EAAavC,UAAUiD,IAAM,SAA2B0D,GACvD,GAAIzH,GAAOC,IAEX,OAAOD,GAAKwE,YAAYE,SAAS6D,eAAgBd,IAUlDpE,EAAavC,UAAU8H,KAAO,SAA4BnB,EAAIuB,GAkC7D,QAASgB,GAAmBrD,GAC3B,IAAKA,EAAeC,KAAM5F,EAAcsF,YACvC,KAAM,IAAInF,OAAO,+FAAiGH,EAAcsF,WAAa,KAG9I,IAAIO,GAAYF,EAAeC,KAAM5F,EAAcsF,WAInDtG,GAAKwI,gBAAiBxI,EAAK2E,iBAAkB3D,EAAcyD,gBAAkBzD,EAAcsF,YAC1FO,EACA,UACA,EAMD,IAAIgB,GAAe7H,EAAK4F,aAAciB,EAEtC,OADA7G,GAAK+G,wBAAyBc,GACvBA,EAOR,QAASoC,GAA0BtD,GAKlC,GAJA3G,EAAKoF,aAAa6B,MAAOjH,EAAKuF,UAAY,sCAAwCkC,EAAK,qBACtFd,GACD3G,EAAKqF,MAAM6B,MAAO,cAAeP,GAE7B3G,EAAK0F,cACR,KAAMiB,GAlER,GAAI3G,GAAOC,IAMX,IAJA+I,EAAcA,KAAgB,EAE9BhJ,EAAKoF,aAAa1E,MAAOV,EAAKuF,UAAY,sBAAwBkC,EAAK,kBAAoBuB,EAAc,OAEpGA,EAAc,CAClB,GAAIkB,GAAc,CAGdlK,GAAKwE,YAAYE,WACpBwF,EAAclK,EAAKwE,YAAYE,SAAS6D,eAAgBd,GAAOzH,EAAKwE,YAAYE,SAAU+C,GAAOzH,EAAKwE,YAAYhD,OAGnH,KAAK,GAAIK,GAAS7B,EAAKwE,YAAa0F,GAC/BA,EAAclK,EAAKwE,YAAYhD,SAC7B0I,EAAarI,EAAS7B,EAAKwE,YAAa0F,GAC9C,GAAIrI,EAAO4F,KAAOA,EAEjB,MADAzH,GAAKoF,aAAa1E,MAAOV,EAAKuF,UAAY,sBAAwBkC,EAAK,2BAChEzH,EAAKsF,EAAE8C,KAAMvG,GAOvB,MAFA7B,GAAKoF,aAAa1E,MAAOV,EAAKuF,UAAY,sBAAwBkC,EAAK,8BAEhEzH,EAAKmK,gBAAiB1C,GAC3BkB,KAAMqB,EAAmBC,IAkD5B5G,EAAavC,UAAUqJ,gBAAkB,SAAqC1C,GAyB7E,QAAS2C,GAAwB3C,EAAId,GAEpC,aADO3G,GAAK6E,eAAgB4C,GACrBd,EA1BR,GAAI3G,GAAOC,IAEX,IAAID,EAAK4E,oBAAsB5E,EAAK6E,gBAAkB7E,EAAK6E,eAAgB4C,GAE1E,MADAzH,GAAKoF,aAAa1E,MAAOV,EAAKuF,UAAY,sBAAwBkC,EAAK,gCAChEzH,EAAK6E,eAAgB4C,EAI7BzH,GAAK2E,iBAAmD3E,EAAK2E,qBAC7D3E,EAAK2E,iBAAkB3D,EAAcyD,gBAAmBzE,EAAK2E,iBAAkB3D,EAAcyD,mBAE7F,IAAI4F,GAAarJ,EAAckH,WAAcT,EAAO,IAAMA,EAAO,IAG7DxC,EAAUjF,EAAKmF,cACjBjB,IAAKlE,EAAK8E,kBAAkBG,QAAUoF,EAAarK,EAAKkF,WAAYmF,IACpE1B,KAAMyB,EAAuBzI,KAAM3B,EAAMyH,GAM3C,OAJIzH,GAAK4E,oBAAsB5E,EAAK6E,iBACnC7E,EAAK6E,eAAgB4C,GAAOxC,GAGtBA,GAcR5B,EAAavC,UAAUwJ,OAAS,SAA8BzI,EAAQ6E,GACrE,GAAI1G,GAAOC,IAEXyG,GAAeA,IAAgB,CAG/B,IAAI6D,GAAavK,EAAKwK,cAAe3I,GAEjC4I,EAAazK,EAAK2F,WAAY4E,GAG9BG,IAIJ,OAHAA,GAAe1J,EAAcsF,YAAemE,EAGxC,mBAAuB5I,GAAO4F,GAC1BzH,EAAKmF,cACVwF,IAAK3J,EAAckH,UAAY,IAAMrG,EAAO4F,GAAIiD,GAChD/B,KAAMlC,EAAkB9E,KAAM3B,EAAM0G,GAAgBM,EAAuBrF,KAAM3B,IAI5EA,EAAKmF,cACVyF,KAAM5J,EAAciH,cAAeyC,GACnC/B,KAAMlC,EAAkB9E,KAAM3B,EAAM0G,GAAgBM,EAAuBrF,KAAM3B,KAIrFqD,EAAavC,UAAU+J,MAAQ,SAA6BhJ,EAAQ6E,GACnE,GAAI1G,GAAOC,IAEXyG,GAAeA,IAAgB,CAG/B,IAAI6D,GAAavK,EAAKwK,cAAe3I,GAEjC4I,EAAazK,EAAK2F,WAAY4E,GAG9BG,IAIJ,IAHAA,EAAe1J,EAAcsF,YAAemE,EAGxC,mBAAuB5I,GAAO4F,GACjC,MAAOzH,GAAKmF,cACV0F,MAAO7J,EAAckH,UAAY,IAAMrG,EAAO4F,GAAIiD,GAClD/B,KAAMlC,EAAkB9E,KAAM3B,EAAM0G,GAAgBM,EAAuBrF,KAAM3B,GAGnF,MAAM,IAAImB,OAAO,sEAOnBkC,EAAavC,UAAUgK,OAASzH,EAAavC,UAAUwJ,OAuDvDjH,EAAavC,UAAbuC,UAAgC,SAA8BxB,GAa7D,QAASkJ,GAAiBpE,GAMzB,MALA3G,GAAKwI,gBAAiBxI,EAAK2E,iBAAkB3D,EAAcyD,gBAAkBzD,EAAcsF,YAC1FzE,EACA,UACA,GAEM7B,EAAKyI,wBAAyBuC,GAOtC,QAASC,GAAwBtE,GAIhC,GAHA3G,EAAKoF,aAAa6B,MAAON,EAAeC,MACxC5G,EAAKqF,MAAM6B,MAAO,cAAeP,GAE7B3G,EAAK0F,cACR,KAAMiB,GA9BR,GAAI3G,GAAOC,KAEP+K,EAAWnJ,EAAO4F,EACtB,OAAOzH,GAAKmF,cAALnF,UACGgB,EAAckH,UAAY,IAAM8C,GACxCrC,KAAMoC,GAFD/K,SAGEiL,IAkCV5H,EAAavC,UAAUiG,wBAA0B,SAA6CS,GAC7F,GAAIxH,GAAOC,IAKX,OAHAD,GAAKoF,aAAaoB,KAAMxG,EAAKuF,UAAY,qBAAwBiC,EAAcC,IAAMzH,EAAKkB,MAAS,cAClGsG,GAEMxH,EAAKwI,gBAAiBxI,EAAKwE,YAAagD,EAAe,UAAU,IAWzEnE,EAAavC,UAAU0H,gBAAkB,SAAqCZ,EAAOJ,EAAe0D,EAAWC,GAC9G,GAAInL,GAAOC,KAEPiK,EAAc,EACdrI,EAAc+F,EAAOsC,EAEzB,IAAIlK,EAAK6F,SACH7F,EAAK6F,OAAQ2B,GAGjB,WAFAxH,GAAKoF,aAAaoB,KAAMxG,EAAKuF,UAAY,YAAeiC,EAAcC,IAAMzH,EAAKkB,MAAS,kBACzFsG,EAUH,QALII,EAAMlD,WACTwF,EAActC,EAAMlD,SAAS6D,eAAgBf,EAAcC,IAAOG,EAAMlD,SAAU8C,EAAcC,IAAOG,EAAMpG,OAC7GK,EAAc+F,EAAOsC,IAGdgB,GACP,IAAK,SACJ,IAAKxD,MAAMC,QAASC,GA0BnB,MAzBIuD,IAEHnL,EAAKqF,MAAM+B,WAAY,uBAErB1E,QAAU1C,EACV4H,MAAUA,EACV/F,OAAU+F,EACVwD,QAAU5D,IAIiB,kBAAnBI,GAAMyD,SAChBzD,EAAMyD,SAAU7D,GAGhB/H,QAAQuF,OAAQ4C,EAAOJ,OAIxBxH,GAAKqF,MAAM+B,WAAY,iBAErB1E,QAAU1C,EACV4H,MAAUA,EACV/F,OAAU+F,GAKb,IAAI0D,IAAQ,CACZ,KAAK7L,QAAQ8L,KAAMrB,EAActC,EAAMpG,SAAU0I,EAAarI,EAAS+F,EAAOsC,GAC7E,GAAIrI,EAAO4F,KAAOD,EAAcC,GAAK,CAChC0D,GAEHnL,EAAKqF,MAAM+B,WAAY,uBAErB1E,QAAU1C,EACV4H,MAAUA,EACV/F,OAAU+F,EAAOsC,GACjBkB,QAAU5D,GAKb,IAAIgE,GAAe5D,EAAOsC,EACW,mBAA1BsB,GAAaH,SACvBG,EAAaH,SAAU7D,GAGvB/H,QAAQuF,OAAQwG,EAAchE,GAG/B8D,GAAQ,EAEJH,GAEHnL,EAAKqF,MAAM+B,WAAY,iBAErB1E,QAAU1C,EACV4H,MAAUA,EACV/F,OAAU+F,EAAOsC,IAGpB,OAKGoB,IACAH,GACHnL,EAAKqF,MAAM+B,WAAY,mBACtB1E,QAAU1C,EACV4H,MAAUA,EACV/F,OAAU2F,IAIZI,EAAM1F,KAAMsF,GACRI,EAAMlD,WACTkD,EAAMlD,SAAU8C,EAAcC,IAAOG,EAAMpG,OAAS,GAGjD2J,GACHnL,EAAKqF,MAAM+B,WAAY,aACtB1E,QAAU1C,EACV4H,MAAUA,EACV/F,OAAU2F,IAIb,MAED,KAAK,SAEJ,IAAK/H,QAAQ8L,KAAMrB,EAActC,EAAMpG,SAAU0I,EAAarI,EAAS+F,EAAOsC,GAC7E,GAAIrI,EAAO4F,KAAOD,EAAcC,GAAK,CAapC,GAZI0D,GAEHnL,EAAKqF,MAAM+B,WAAY,uBACtB1E,QAAU1C,EACV4H,MAAUA,EACV/F,OAAUA,IAKZ+F,EAAM3E,OAAQiH,EAAa,GAEvBtC,EAAMlD,SAAW,OACbkD,GAAMlD,SAAU8C,EAAcC,GAErC,KAAK,GAAIgE,KAAc7D,GAAMlD,SACxBwF,GAAetC,EAAMlD,SAAU+G,MAChC7D,EAAMlD,SAAU+G,GAKjBN,GAEHnL,EAAKqF,MAAM+B,WAAY,iBACtB1E,QAAU1C,EACV4H,MAAUA,EACV/F,OAAUA,GAGZ,UAYLwB,EAAavC,UAAU2H,wBAA0B,SAA6ChB,GAC7F,GAAIzH,GAAOC,IAEX,OAAOD,GAAKwI,gBAAiBxI,EAAKwE,aACjCiD,GAAKA,GACH,UAAU,IAQdpE,EAAavC,UAAU4K,gBAAkB,WAIxC,IAAK,GAHD1L,GAAOC,KAEP0L,KACKzB,EAAc,EAClBA,EAAclK,EAAKwE,YAAYhD,SAC7B0I,EACNyB,EAAa3L,EAAKwE,YAAa0F,GAAczC,IAAOzH,EAAKwE,YAAa0F,EAEvE,OAAOyB,IAURtI,EAAavC,UAAU0J,cAAgB,SAAqC3I,EAAQ+J,GACnF,GAAI5L,GAAOC,KAEP4L,EAASD,OACb,KAAK,GAAIE,KAAgBjK,GACnBA,EAAO0G,eAAgBuD,KAKxBpE,MAAMC,QAAS9F,EAAQiK,IAC1BD,EAAQC,GAAiB9L,EAAKwK,cAAe3I,EAAQiK,IAAgB,GAKlEjK,EAAQiK,IAAkBjK,EAAQiK,GAAerE,GACpDoE,EAAQC,GAAiBjK,EAAQiK,GAAerE,GAKjDoE,EAAQC,GAAiBjK,EAAQiK,GAElC,OAAOD,IAkBRxI,EAAavC,UAAUiL,gBAAkB,SAAuClK,EAAQiK,EAAclE,EAAOoE,GAqD5G,QAASC,GAAqBC,EAASC,GAqBtC,QAASC,GAAoBC,GAQ5B,MANAxK,GAAQiK,GAAgBK,GAAUE,EAE9BL,EAAQM,WACXA,EAAWD,EAASxK,GAGdA,EA3BR,GAA+C,gBAApCA,GAAQiK,GAAgBK,GAAuB,CAEzD,IAAIH,EAAQO,OAAoD,gBAApC1K,GAAQiK,GAAgBK,IAAsE,gBAAvCtK,GAAQiK,GAAgBK,GAAQ1E,GAI5G,CACN,GAAIzH,EAAK0F,cACR,KAAM,IAAIvE,OAAO,8EAGlB,OAAOnB,GAAKsF,EAAE8C,MAAM,GAPpBvG,EAAQiK,GAAgBK,GAAUtK,EAAQiK,GAAgBK,GAAQ1E,GAYpE,MAAOG,GAAMgB,KAAM/G,EAAQiK,GAAgBK,IACzCxD,KAAMyD,GAcT,QAASA,GAAoBC,GAQ5B,MANAxK,GAAQiK,GAAiBO,EAErBL,EAAQM,WACXA,EAAWD,EAASxK,GAGdA,EAGR,QAASyK,GAAWD,EAASxK,GAE5B,GAAI6F,MAAMC,QAAS0E,EAASL,EAAQQ,oBAAwB,CAE3D,GAAIC,GAAUJ,EAASL,EAAQQ,mBAAoBE,QAAS7K,EAAO4F,GACnE,OAASgF,EAGR,YADAJ,EAASL,EAAQQ,mBAAqBC,GAAY5K,EAKnD,KAAK,GAAI8K,GAAc,EAAGC,EAAeP,EAASL,EAAQQ,mBAAqB,GAC1EG,EAAcN,EAASL,EAAQQ,mBAAoBhL,SACjDmL,EAAaC,EAAeP,EAASL,EAAQQ,mBAAqBG,GAAgB,CAExF,GAAIC,IAAiB/K,EACpB,MAID,IAAI+K,EAAanF,KAAO5F,EAAO4F,GAE9B,YADA4E,EAASL,EAAQQ,mBAAqBG,GAAgB9K,GAOxD,WADAwK,GAASL,EAAQQ,mBAAoBtK,KAAML,GAI5CwK,EAASL,EAAQQ,mBAAsB3K,EAhIxC,GAAI7B,GAAOC,IAoBX,IAlBA+L,EAAUA,MACa,iBAAZA,KACVhM,EAAKoF,aAAayH,KAAM,oEACxBb,GACCO,MAAQP,IAGVA,EAAQO,MAAoBP,EAAQO,QAAS,EAC7CP,EAAQM,UAAoBN,EAAQM,YAAa,EACjDN,EAAQQ,kBAAoBR,EAAQQ,mBAAqB,GAErDR,EAAQM,YAAcN,EAAQQ,oBACjCxM,EAAKoF,aAAayH,KACjB,yFACDb,EAAQM,WAAY,GAIjB5E,MAAMC,QAAS9F,EAAQiK,IAAmB,CAE7C,GAAIgB,GAAWjL,EAAQiK,GAAeiB,IAAKd,EAE3C,OAAOjM,GAAKsF,EAAE0H,IAAKF,GAGnB,GAA+B,OAA3BjL,EAAQiK,GACX,MAAO9L,GAAKsF,EAAE8C,KAAM,MAClBO,KAAMyD,EAIT,IAAsC,gBAA3BvK,GAAQiK,GAA8B,CAEhD,IAAIE,EAAQO,OAA2C,gBAA3B1K,GAAQiK,IAAoE,gBAA9BjK,GAAQiK,GAAerE,GAI1F,CACN,GAAIzH,EAAK0F,cACR,KAAM,IAAIvE,OAAO,8EAElB,OAAOnB,GAAKsF,EAAE8C,MAAM,GANpBvG,EAAQiK,GAAiBjK,EAAQiK,GAAerE,GAWlD,MAAOG,GAAMgB,KAAM/G,EAAQiK,IACzBnD,KAAMyD,IAwFV/I,EAAavC,UAAUmM,MAAQ,WAC9B,GAAIjN,GAAOC,IAEXD,GAAKwE,YAAuBxE,EAAKgB,cAAcyD,qBAC/CzE,EAAKwE,YAAYE,SAAW1E,EAAKwE,YAAYE,aAE7C1E,EAAK2E,iBAAmB,KACxB3E,EAAK6E,mBAGNxB,EAAavC,UAAU8B,SAAW,WACjC,GAAI5C,GAAOC,IAEXD,GAAK0D,OAAOX,IAAK/C,EAAK8F,4BACtB9F,EAAK0D,OAAOX,IAAK/C,EAAKgG,gCAElBhG,EAAKkG,wBAAwBjE,YAChCjC,EAAKkG,wBAAwBjE,aAE1BjC,EAAKoG,4BAA4BnE,YACpCjC,EAAKoG,4BAA4BnE,cAI5BoB,EAGR,QAASgB,GAAmBL,GAC3B,MAAOA,GA9oCRvE,QACEC,OAAQ,UACRwN,SAAU,cAAe9J,MChB1B,WACD,YAOA,SAAS+J,KACR,MAAOC,GA4BR,QAASA,GAA4BpJ,EAAOiE,EAAeC,EAAWzD,EAAgB6B,EAAY/B,EAAaH,EAAW7B,EAAU7B,EAAOoE,GAC1I7E,KAAK+D,MAAgBA,EACrB/D,KAAKgI,cAAgBA,EACrBhI,KAAKiI,UAAgBA,CAErB,IAAImF,GAAkBrJ,EAAMlD,UAAUG,YAAYC,KAAKoM,aACvDrN,MAAKwE,eAAiBA,GAAoB4I,EAAa,IACvDpN,KAAKqG,WAAiBA,GAAc+G,EAEpCpN,KAAKsE,YAAcA,GAAe5D,OAClCV,KAAKmE,UAAcA,GAAazD,OAEhCV,KAAKsC,SAAWA,GAAY5B,OAE5BV,KAAKS,MAAQA,IAAS,EAEtBT,KAAK6E,kBAAoBrF,QAAQsF,UAChCpC,MAAU,EACVsC,SAAU,GACRH,GApDJrF,QACEC,OAAQ,UACRgD,QAAS,6BAA8ByK,MCNxC,WACD,YAGA1N,SACEC,OAAQ,UACRwN,SAAU,iBACVxM,MAAQjB,QAAQ8L,KAChB/E,KAAQ/G,QAAQ8L,KAChBsB,KAAQpN,QAAQ8L,KAChBtE,MAAQxH,QAAQ8L,UCVjB,WACD,YAOA,SAASgC,KAGR,QAASC,GAAgBC,GACxB,IAAKA,EACJ,MAAOA,EAGR,IAAIC,MAAqBD,EAAIf,QAAS,KAAQ,IAAM,IAChDiB,GAAgB,GAAIC,OAAOC,SAE/B,OAAOJ,GAAMC,EAAY,KAAOC,EAVjC,MAAOH,GALR/N,QACEC,OAAQ,UACRmG,OAAQ,iBAAkB0H","file":"absync.concat.min.js","sourcesContent":["(function() {\n\"use strict\";\n/* globals angular */\n\nangular.module( \"absync\", [] );\n}());","(function() {\n\"use strict\";\n/* globals angular, io */\n\n/**\n * Please make note of the following conventions:\n * 1. Function-scope local variables must be prefixed with a single underscore.\n *    This indicates a temporary variable.\n * 2. Private variables that are persisted onto publicly accessible entities must be prefixed with two underscores.\n *    This indicates a publicly visible, private variable.\n *    Hiding private variables, by using closures, is discouraged.\n *    Modifying these values from outside of absync is discouraged, but should be respected whenever possible.\n */\n\nangular\n\t.module( \"absync\" )\n\t.provider( \"absync\", getAbsyncProvider );\n\n/**\n * Retrieves the absync provider.\n * @param {angular.auto.IInjectorService|Object} $injector The $injector provider.\n * @param {angular.auto.IProvideService|Object} $provide The $provide provider\n * @param {Function} absyncCache The AbsyncCache service constructor.\n * @ngInject\n */\nfunction getAbsyncProvider( $injector, $provide, absyncCache ) {\n\treturn new AbsyncProvider( $injector, $provide, absyncCache );\n}\n\n/**\n * Retrieves the absync provider.\n * @param {angular.auto.IInjectorService|Object} $injector The $injector provider.\n * @param {angular.auto.IProvideService|Object} $provide The $provide provider.\n * @param {Function} absyncCache The AbsyncCache service constructor.\n * @constructor\n */\nfunction AbsyncProvider( $injector, $provide, absyncCache ) {\n\tvar self = this;\n\n\tself.__injector    = $injector;\n\t// Store a reference to the provide provider.\n\tself.__provide     = $provide;\n\t// Store a reference to the cache service constructor.\n\tself.__absyncCache = absyncCache;\n\n\t// A reference to the socket.io instance we're using to receive updates from the server.\n\tself.__ioSocket = null;\n\t// We usually register event listeners on the socket.io instance right away.\n\t// If socket.io was not connected when a service was constructed, we put the registration request\n\t// into this array and register it as soon as socket.io is configured.\n\tself.__registerLater = [];\n\t// References to all registered event listeners.\n\tself.__listeners     = [];\n\n\t// The collections that absync provides.\n\t// The keys are the names of the collections, the value contains the constructor of\n\t// the respective cache service.\n\tself.__collections = {};\n\n\t// The entities that absync provides.\n\t// The keys are the names of the entities, the value contains the constructor of\n\t// the respective cache service.\n\tself.__entities = {};\n\n\t// Debug should either be set through a configure() call, or on instantiated services.\n\tself.debug = undefined;\n}\n\n/**\n * Register the configurator on the provider itself to allow early configuration during setup phase.\n * It is recommended to configure absync within a configuration phase of a module.\n * @param {Object} configuration The configuration for the absync provider.\n * Can have a member `socket`, pointing to the socket.io instance or constructor to use.\n * Can have a member `debug`, enabling debugging, if set to true.\n */\nAbsyncProvider.prototype.configure = function AbsyncProvider$configure( configuration ) {\n\tvar self = this;\n\n\tif( configuration.constructor.name === \"Socket\" ) {\n\t\tthrow new Error( \"configure() expects input to be hash that provides the Socket.IO instance through a 'socket' property.\" );\n\t}\n\n\tif( typeof configuration.socket !== \"undefined\" ) {\n\t\tvar socket   = configuration.socket;\n\t\t// Determine if the socket is an io.Socket.\n\t\tvar isSocket = typeof io !== \"undefined\" && io.Socket && socket instanceof io.Socket;\n\n\t\tif( typeof socket == \"function\" ) {\n\t\t\t// Expect the passed socket to be a constructor.\n\t\t\tself.__ioSocket = new socket();// jscs:ignore requireCapitalizedConstructors\n\n\t\t} else if( isSocket ) {\n\t\t\t// Expect the passed socket to be an io.Socket instance.\n\t\t\tself.__ioSocket = socket;\n\n\t\t} else {\n\t\t\tthrow new Error( \"configure() expects the socket to be a Socket constructor or a socket.io Socket instance.\" );\n\t\t}\n\n\t\t// Check if services already tried to register listeners, if so, register them now.\n\t\t// This can happen when a service was constructed before absync was configured.\n\t\tif( self.__registerLater.length ) {\n\t\t\tangular.forEach( self.__registerLater, self.__registerListener.bind( self ) );\n\t\t\tself.__registerLater = [];\n\t\t}\n\t}\n\n\tif( typeof configuration.debug !== \"undefined\" ) {\n\t\tself.debug = configuration.debug || false;\n\t}\n\n\tif( self.debug ) {\n\t\tangular.forEach( self.__collections, function enableDebugging( collection ) {\n\t\t\tcollection.configuration.debug = true;\n\t\t} );\n\t\tangular.forEach( self.__entities, function enableDebugging( entity ) {\n\t\t\tentity.configuration.debug = true;\n\t\t} );\n\t}\n};\n\n/**\n * Detaches absync from the websocket.\n * @param {Boolean} [disconnectSocket=false] Should the underlying socket.io connection be disconnected as well?\n */\nAbsyncProvider.prototype.disconnect = function AbsyncProvider$disconnect( disconnectSocket ) {\n\tvar self = this;\n\n\tdisconnectSocket = disconnectSocket || false;\n\n\tangular.forEach( self.__listeners, function unregisterListener( listener ) {\n\t\tlistener.unregister();\n\t\tdelete listener.unregister;\n\t\tself.__registerLater.push( listener );\n\t} );\n\n\tself.__listeners = [];\n\n\tif( disconnectSocket ) {\n\t\tself.__ioSocket.disconnect();\n\t\tself.__ioSocket = null;\n\t}\n};\n\n/**\n * Register an event listener with socket.io.\n * @param {Object} listener\n * @private\n */\nAbsyncProvider.prototype.__registerListener = function AbsyncProvider$registerListener( listener ) {\n\tvar self = this;\n\n\t// Remember this listener.\n\tself.__listeners.push( listener );\n\n\t// Register the listener and remember the function to use when the listener should be unregistered.\n\tlistener.unregister = self.__registerEntityEventListener( listener.eventName, listener.callback );\n};\n\n/**\n * Request a new synchronized collection.\n * This only registers the intent to use that collection. It will be constructed when it is first used.\n * @param {String} name The name of the collection and service name.\n * @param {AbsyncServiceConfiguration|Object} configuration The configuration for this collection.\n */\nAbsyncProvider.prototype.collection = function AbsyncProvider$collection( name, configuration ) {\n\tvar self = this;\n\n\t// Collection/entity names (and, thus service names) have to be unique.\n\t// We can't create multiple services with the same name.\n\tif( self.__collections[ name ] ) {\n\t\tthrow new Error( \"A collection with the name '\" + name + \"' was already requested. Names for collections must be unique.\" );\n\t}\n\tif( self.__entities[ name ] ) {\n\t\tthrow new Error( \"An entity with the name '\" + name + \"' was already requested. Names for collections must be unique and can't be shared with entities.\" );\n\t}\n\n\t// If no debug flag was set, use the value from the core absync provider.\n\tconfiguration.debug = typeof configuration.debug === \"undefined\" ? self.debug : configuration.debug;\n\n\t// Register the service configuration.\n\t// __absyncCache will return a constructor for a service with the given configuration.\n\tself.__collections[ name ] = {\n\t\tconstructor   : self.__absyncCache( name, configuration ),\n\t\tconfiguration : configuration\n\t};\n\n\tif( configuration.provideService === false ) {\n\t\tif( !configuration.injector ) {\n\t\t\tvar $injector = angular.injector( [ \"ng\", \"todomvc\" ] );\n\t\t\tconfiguration.injector = $injector;\n\t\t\t//throw new Error( \"Injector is missing in service configuration.\" );\n\t\t}\n\t\tself.__collections[ name ].instance = configuration.injector.instantiate( self.__collections[ name ].constructor );\n\t\treturn self.__collections[ name ].instance;\n\t}\n\n\t// Register the new service.\n\t// Yes, we want an Angular \"service\" here, because we want it constructed with \"new\".\n\tself.__provide.service( name, self.__collections[ name ].constructor );\n};\n\n/**\n * Request a new synchronized entity.\n * This only registers the intent to use that entity. It will be constructed when it is first used.\n * @param {String} name The name of the entity and service name.\n * @param {AbsyncServiceConfiguration|Object} configuration The configuration for this entity.\n */\nAbsyncProvider.prototype.entity = function AbsyncProvider$entity( name, configuration ) {\n\tvar self = this;\n\n\t// Collection/entity names (and, thus service names) have to be unique.\n\t// We can't create multiple services with the same name.\n\tif( self.__entities[ name ] ) {\n\t\tthrow new Error( \"An entity with the name '\" + name + \"' was already requested. Names for entities must be unique.\" );\n\t}\n\tif( self.__collections[ name ] ) {\n\t\tthrow new Error( \"A collection with the name '\" + name + \"' was already requested. Names for entities must be unique and can't be shared with collections.\" );\n\t}\n\n\t// If no debug flag was set, use the value from the core absync provider.\n\tconfiguration.debug = typeof configuration.debug === \"undefined\" ? self.debug : configuration.debug;\n\n\t// Register the service configuration.\n\t// __absyncCache will return a constructor for a service with the given configuration.\n\tself.__entities[ name ] = {\n\t\tconstructor   : self.__absyncCache( name, configuration ),\n\t\tconfiguration : configuration\n\t};\n\n\tif( configuration.provideService === false ) {\n\t\tvar $injector = angular.injector( [ \"ng\", \"absync\" ] );\n\t\treturn $injector.instantiate( self.__collections[ name ].constructor );\n\t}\n\n\t// Register the new service.\n\t// Yes, we want an Angular \"service\" here, because we want it constructed with \"new\".\n\tself.__provide.service( name, self.__entities[ name ].constructor );\n};\n\nAbsyncProvider.prototype.sync = function AbsyncProvider$sync( name, configuration ) {\n\tvar self = this;\n\n\tif( self.__collections[ name ] && self.__collections[ name ].instance ) {\n\t\treturn self.__collections[ name ].instance;\n\t}\n\n\t//configuration.injector       = self.__injector;\n\tconfiguration.provideService = false;\n\n\treturn self.collection( name, configuration );\n};\n\n/**\n * Destroy a service.\n * @param {CacheService} service\n */\nAbsyncProvider.prototype.teardown = function AbsyncProvider$teardown( service ) {\n\tvar self = this;\n\n\tvar serviceDefinition = self.__entities[ service.name ] || self.__collections[ service.name ];\n\tif( !serviceDefinition ) {\n\t\tthrow new Error( \"A service with the name '\" + service.name + \"' was not registered.\" );\n\t}\n\n\tif( serviceDefinition.configuration.provideService !== false ) {\n\t\tthrow new Error( \"The service '\" + service.name + \"' was registered as an injectable service and can not be torn down.\" );\n\t}\n\n\tdelete self.__entities[ service.name ];\n\tdelete self.__collections[ service.name ];\n\n\tservice.teardown();\n};\n\n/**\n * Register an event listener that is called when a specific entity is received on the websocket.\n * @param {String} eventName The event name, usually the name of the entity.\n * @param {Function} callback The function to call when the entity is received.\n * @return {Function|null} If the listener could be registered, it returns a function that, when called, removes\n * the event listener.\n * If the listener registration was delayed, null is returned.\n */\nAbsyncProvider.prototype.on = function AbsyncProvider$on( eventName, callback ) {\n\tvar self = this;\n\n\t// If we have no configured socket.io connection yet, remember to register it later.\n\tif( !self.__ioSocket ) {\n\n\t\tif( self.__registerLater.length > 8192 ) {\n\t\t\t// Be defensive, something is probably not right here.\n\t\t\treturn null;\n\t\t}\n\n\t\t// TODO: Use promises here, so that we can always return the event listener removal function.\n\t\tself.__registerLater.push( {\n\t\t\teventName : eventName,\n\t\t\tcallback  : callback\n\t\t} );\n\t\treturn null;\n\t}\n\n\treturn self.__registerListener( {\n\t\teventName : eventName,\n\t\tcallback  : callback\n\t} );\n};\n\n/**\n * Remove a previous registered listener.\n * @param {String} eventName\n * @param {Function} callback\n */\nAbsyncProvider.prototype.off = function AbsyncProvider$off( eventName, callback ) {\n\tvar self = this;\n\n\tfor( var listenerIndex = 0; listenerIndex < self.__listeners.length; ++listenerIndex ) {\n\t\tif( self.__listeners[ listenerIndex ].eventName === eventName && self.__listeners[ listenerIndex ].callback === callback ) {\n\t\t\tself.__listeners.splice( listenerIndex, 1 );\n\t\t\tself.__listeners[ listenerIndex ].unregister();\n\t\t\treturn;\n\t\t}\n\t}\n};\n\n/**\n * Register an event listener on the websocket.\n * @param {String} eventName The event name, usually the name of the entity.\n * @param {Function} callback The function to call when the entity is received.\n * @returns {Function}\n */\nAbsyncProvider.prototype.__registerEntityEventListener = function AbsyncProvider$registerEntityEventListener( eventName, callback ) {\n\tvar self = this;\n\n\t// Register the callback with socket.io.\n\tself.__ioSocket.on( eventName, callback );\n\n\t// Return a function that removes the listener.\n\treturn function removeListener() {\n\t\tself.__ioSocket.removeListener( eventName, callback );\n\t};\n};\n\n/**\n * The service is just used as a convenience to access the provider.\n * @returns {AbsyncProvider}\n * @ngInject\n */\nAbsyncProvider.prototype.$get = function AbsyncProvider$$get() {\n\treturn this;\n};\n}());","(function() {\n\"use strict\";\n/* globals angular */\n\nangular.module( \"absync\", [] );\n}());;(function() {\n\"use strict\";\n/* globals angular, io */\n\n/**\n * Please make note of the following conventions:\n * 1. Function-scope local variables must be prefixed with a single underscore.\n *    This indicates a temporary variable.\n * 2. Private variables that are persisted onto publicly accessible entities must be prefixed with two underscores.\n *    This indicates a publicly visible, private variable.\n *    Hiding private variables, by using closures, is discouraged.\n *    Modifying these values from outside of absync is discouraged, but should be respected whenever possible.\n */\n\ngetAbsyncProvider.$inject = [\"$injector\", \"$provide\", \"absyncCache\"];\nangular\n\t.module( \"absync\" )\n\t.provider( \"absync\", getAbsyncProvider );\n\n/**\n * Retrieves the absync provider.\n * @param {angular.auto.IInjectorService|Object} $injector The $injector provider.\n * @param {angular.auto.IProvideService|Object} $provide The $provide provider\n * @param {Function} absyncCache The AbsyncCache service constructor.\n * @ngInject\n */\nfunction getAbsyncProvider( $injector, $provide, absyncCache ) {\n\treturn new AbsyncProvider( $injector, $provide, absyncCache );\n}\n\n/**\n * Retrieves the absync provider.\n * @param {angular.auto.IInjectorService|Object} $injector The $injector provider.\n * @param {angular.auto.IProvideService|Object} $provide The $provide provider.\n * @param {Function} absyncCache The AbsyncCache service constructor.\n * @constructor\n */\nfunction AbsyncProvider( $injector, $provide, absyncCache ) {\n\tvar self = this;\n\n\tself.__injector    = $injector;\n\t// Store a reference to the provide provider.\n\tself.__provide     = $provide;\n\t// Store a reference to the cache service constructor.\n\tself.__absyncCache = absyncCache;\n\n\t// A reference to the socket.io instance we're using to receive updates from the server.\n\tself.__ioSocket = null;\n\t// We usually register event listeners on the socket.io instance right away.\n\t// If socket.io was not connected when a service was constructed, we put the registration request\n\t// into this array and register it as soon as socket.io is configured.\n\tself.__registerLater = [];\n\t// References to all registered event listeners.\n\tself.__listeners     = [];\n\n\t// The collections that absync provides.\n\t// The keys are the names of the collections, the value contains the constructor of\n\t// the respective cache service.\n\tself.__collections = {};\n\n\t// The entities that absync provides.\n\t// The keys are the names of the entities, the value contains the constructor of\n\t// the respective cache service.\n\tself.__entities = {};\n\n\t// Debug should either be set through a configure() call, or on instantiated services.\n\tself.debug = undefined;\n}\n\n/**\n * Register the configurator on the provider itself to allow early configuration during setup phase.\n * It is recommended to configure absync within a configuration phase of a module.\n * @param {Object} configuration The configuration for the absync provider.\n * Can have a member `socket`, pointing to the socket.io instance or constructor to use.\n * Can have a member `debug`, enabling debugging, if set to true.\n */\nAbsyncProvider.prototype.configure = function AbsyncProvider$configure( configuration ) {\n\tvar self = this;\n\n\tif( configuration.constructor.name === \"Socket\" ) {\n\t\tthrow new Error( \"configure() expects input to be hash that provides the Socket.IO instance through a 'socket' property.\" );\n\t}\n\n\tif( typeof configuration.socket !== \"undefined\" ) {\n\t\tvar socket   = configuration.socket;\n\t\t// Determine if the socket is an io.Socket.\n\t\tvar isSocket = typeof io !== \"undefined\" && io.Socket && socket instanceof io.Socket;\n\n\t\tif( typeof socket == \"function\" ) {\n\t\t\t// Expect the passed socket to be a constructor.\n\t\t\tself.__ioSocket = new socket();// jscs:ignore requireCapitalizedConstructors\n\n\t\t} else if( isSocket ) {\n\t\t\t// Expect the passed socket to be an io.Socket instance.\n\t\t\tself.__ioSocket = socket;\n\n\t\t} else {\n\t\t\tthrow new Error( \"configure() expects the socket to be a Socket constructor or a socket.io Socket instance.\" );\n\t\t}\n\n\t\t// Check if services already tried to register listeners, if so, register them now.\n\t\t// This can happen when a service was constructed before absync was configured.\n\t\tif( self.__registerLater.length ) {\n\t\t\tangular.forEach( self.__registerLater, self.__registerListener.bind( self ) );\n\t\t\tself.__registerLater = [];\n\t\t}\n\t}\n\n\tif( typeof configuration.debug !== \"undefined\" ) {\n\t\tself.debug = configuration.debug || false;\n\t}\n\n\tif( self.debug ) {\n\t\tangular.forEach( self.__collections, function enableDebugging( collection ) {\n\t\t\tcollection.configuration.debug = true;\n\t\t} );\n\t\tangular.forEach( self.__entities, function enableDebugging( entity ) {\n\t\t\tentity.configuration.debug = true;\n\t\t} );\n\t}\n};\n\n/**\n * Detaches absync from the websocket.\n * @param {Boolean} [disconnectSocket=false] Should the underlying socket.io connection be disconnected as well?\n */\nAbsyncProvider.prototype.disconnect = function AbsyncProvider$disconnect( disconnectSocket ) {\n\tvar self = this;\n\n\tdisconnectSocket = disconnectSocket || false;\n\n\tangular.forEach( self.__listeners, function unregisterListener( listener ) {\n\t\tlistener.unregister();\n\t\tdelete listener.unregister;\n\t\tself.__registerLater.push( listener );\n\t} );\n\n\tself.__listeners = [];\n\n\tif( disconnectSocket ) {\n\t\tself.__ioSocket.disconnect();\n\t\tself.__ioSocket = null;\n\t}\n};\n\n/**\n * Register an event listener with socket.io.\n * @param {Object} listener\n * @private\n */\nAbsyncProvider.prototype.__registerListener = function AbsyncProvider$registerListener( listener ) {\n\tvar self = this;\n\n\t// Remember this listener.\n\tself.__listeners.push( listener );\n\n\t// Register the listener and remember the function to use when the listener should be unregistered.\n\tlistener.unregister = self.__registerEntityEventListener( listener.eventName, listener.callback );\n};\n\n/**\n * Request a new synchronized collection.\n * This only registers the intent to use that collection. It will be constructed when it is first used.\n * @param {String} name The name of the collection and service name.\n * @param {AbsyncServiceConfiguration|Object} configuration The configuration for this collection.\n */\nAbsyncProvider.prototype.collection = function AbsyncProvider$collection( name, configuration ) {\n\tvar self = this;\n\n\t// Collection/entity names (and, thus service names) have to be unique.\n\t// We can't create multiple services with the same name.\n\tif( self.__collections[ name ] ) {\n\t\tthrow new Error( \"A collection with the name '\" + name + \"' was already requested. Names for collections must be unique.\" );\n\t}\n\tif( self.__entities[ name ] ) {\n\t\tthrow new Error( \"An entity with the name '\" + name + \"' was already requested. Names for collections must be unique and can't be shared with entities.\" );\n\t}\n\n\t// If no debug flag was set, use the value from the core absync provider.\n\tconfiguration.debug = typeof configuration.debug === \"undefined\" ? self.debug : configuration.debug;\n\n\t// Register the service configuration.\n\t// __absyncCache will return a constructor for a service with the given configuration.\n\tself.__collections[ name ] = {\n\t\tconstructor   : self.__absyncCache( name, configuration ),\n\t\tconfiguration : configuration\n\t};\n\n\tif( configuration.provideService === false ) {\n\t\tif( !configuration.injector ) {\n\t\t\tvar $injector = angular.injector( [ \"ng\", \"todomvc\" ] );\n\t\t\tconfiguration.injector = $injector;\n\t\t\t//throw new Error( \"Injector is missing in service configuration.\" );\n\t\t}\n\t\tself.__collections[ name ].instance = configuration.injector.instantiate( self.__collections[ name ].constructor );\n\t\treturn self.__collections[ name ].instance;\n\t}\n\n\t// Register the new service.\n\t// Yes, we want an Angular \"service\" here, because we want it constructed with \"new\".\n\tself.__provide.service( name, self.__collections[ name ].constructor );\n};\n\n/**\n * Request a new synchronized entity.\n * This only registers the intent to use that entity. It will be constructed when it is first used.\n * @param {String} name The name of the entity and service name.\n * @param {AbsyncServiceConfiguration|Object} configuration The configuration for this entity.\n */\nAbsyncProvider.prototype.entity = function AbsyncProvider$entity( name, configuration ) {\n\tvar self = this;\n\n\t// Collection/entity names (and, thus service names) have to be unique.\n\t// We can't create multiple services with the same name.\n\tif( self.__entities[ name ] ) {\n\t\tthrow new Error( \"An entity with the name '\" + name + \"' was already requested. Names for entities must be unique.\" );\n\t}\n\tif( self.__collections[ name ] ) {\n\t\tthrow new Error( \"A collection with the name '\" + name + \"' was already requested. Names for entities must be unique and can't be shared with collections.\" );\n\t}\n\n\t// If no debug flag was set, use the value from the core absync provider.\n\tconfiguration.debug = typeof configuration.debug === \"undefined\" ? self.debug : configuration.debug;\n\n\t// Register the service configuration.\n\t// __absyncCache will return a constructor for a service with the given configuration.\n\tself.__entities[ name ] = {\n\t\tconstructor   : self.__absyncCache( name, configuration ),\n\t\tconfiguration : configuration\n\t};\n\n\tif( configuration.provideService === false ) {\n\t\tvar $injector = angular.injector( [ \"ng\", \"absync\" ] );\n\t\treturn $injector.instantiate( self.__collections[ name ].constructor );\n\t}\n\n\t// Register the new service.\n\t// Yes, we want an Angular \"service\" here, because we want it constructed with \"new\".\n\tself.__provide.service( name, self.__entities[ name ].constructor );\n};\n\nAbsyncProvider.prototype.sync = function AbsyncProvider$sync( name, configuration ) {\n\tvar self = this;\n\n\tif( self.__collections[ name ] && self.__collections[ name ].instance ) {\n\t\treturn self.__collections[ name ].instance;\n\t}\n\n\t//configuration.injector       = self.__injector;\n\tconfiguration.provideService = false;\n\n\treturn self.collection( name, configuration );\n};\n\n/**\n * Destroy a service.\n * @param {CacheService} service\n */\nAbsyncProvider.prototype.teardown = function AbsyncProvider$teardown( service ) {\n\tvar self = this;\n\n\tvar serviceDefinition = self.__entities[ service.name ] || self.__collections[ service.name ];\n\tif( !serviceDefinition ) {\n\t\tthrow new Error( \"A service with the name '\" + service.name + \"' was not registered.\" );\n\t}\n\n\tif( serviceDefinition.configuration.provideService !== false ) {\n\t\tthrow new Error( \"The service '\" + service.name + \"' was registered as an injectable service and can not be torn down.\" );\n\t}\n\n\tdelete self.__entities[ service.name ];\n\tdelete self.__collections[ service.name ];\n\n\tservice.teardown();\n};\n\n/**\n * Register an event listener that is called when a specific entity is received on the websocket.\n * @param {String} eventName The event name, usually the name of the entity.\n * @param {Function} callback The function to call when the entity is received.\n * @return {Function|null} If the listener could be registered, it returns a function that, when called, removes\n * the event listener.\n * If the listener registration was delayed, null is returned.\n */\nAbsyncProvider.prototype.on = function AbsyncProvider$on( eventName, callback ) {\n\tvar self = this;\n\n\t// If we have no configured socket.io connection yet, remember to register it later.\n\tif( !self.__ioSocket ) {\n\n\t\tif( self.__registerLater.length > 8192 ) {\n\t\t\t// Be defensive, something is probably not right here.\n\t\t\treturn null;\n\t\t}\n\n\t\t// TODO: Use promises here, so that we can always return the event listener removal function.\n\t\tself.__registerLater.push( {\n\t\t\teventName : eventName,\n\t\t\tcallback  : callback\n\t\t} );\n\t\treturn null;\n\t}\n\n\treturn self.__registerListener( {\n\t\teventName : eventName,\n\t\tcallback  : callback\n\t} );\n};\n\n/**\n * Remove a previous registered listener.\n * @param {String} eventName\n * @param {Function} callback\n */\nAbsyncProvider.prototype.off = function AbsyncProvider$off( eventName, callback ) {\n\tvar self = this;\n\n\tfor( var listenerIndex = 0; listenerIndex < self.__listeners.length; ++listenerIndex ) {\n\t\tif( self.__listeners[ listenerIndex ].eventName === eventName && self.__listeners[ listenerIndex ].callback === callback ) {\n\t\t\tself.__listeners.splice( listenerIndex, 1 );\n\t\t\tself.__listeners[ listenerIndex ].unregister();\n\t\t\treturn;\n\t\t}\n\t}\n};\n\n/**\n * Register an event listener on the websocket.\n * @param {String} eventName The event name, usually the name of the entity.\n * @param {Function} callback The function to call when the entity is received.\n * @returns {Function}\n */\nAbsyncProvider.prototype.__registerEntityEventListener = function AbsyncProvider$registerEntityEventListener( eventName, callback ) {\n\tvar self = this;\n\n\t// Register the callback with socket.io.\n\tself.__ioSocket.on( eventName, callback );\n\n\t// Return a function that removes the listener.\n\treturn function removeListener() {\n\t\tself.__ioSocket.removeListener( eventName, callback );\n\t};\n};\n\n/**\n * The service is just used as a convenience to access the provider.\n * @returns {AbsyncProvider}\n * @ngInject\n */\nAbsyncProvider.prototype.$get = function AbsyncProvider$$get() {\n\treturn this;\n};\n}());;(function() {\n\"use strict\";\n/* globals angular */\n\n/**\n * Please make note of the following conventions:\n * 1. Function-scope local variables must be prefixed with a single underscore.\n *    This indicates a temporary variable.\n * 2. Private variables that are persisted onto publicly accessible entities must be prefixed with two underscores.\n *    This indicates a publicly visible, private variable.\n *    Hiding private variables, by using closures, is discouraged.\n *    Modifying these values from outside of absync is discouraged, but should be respected whenever possible.\n */\n\nangular\n\t.module( \"absync\" )\n\t.constant( \"absyncCache\", getServiceConstructor );\n\n/**\n * A closure to make the configuration available to the cache service.\n * @param {String} name The name of the service.\n * @param {AbsyncServiceConfiguration} configuration The configuration for this service.\n * @returns {CacheService}\n */\nfunction getServiceConstructor( name, configuration ) {\n\t// There is no code here, other than the CacheService definition, followed by \"return CacheService;\"\n\n\t/**\n\t * This service factory is the core of absync.\n\t * It returns a CacheService instance that is specialized to the given configuration.\n\t * This service will handle keep the stored collection in sync.\n\t * @param {angular.IHttpService|Object} $http\n\t * @param {angular.auto.IInjectorService|Object} $injector\n\t * @param {angular.ILogService|Object} $log\n\t * @param {angular.IQService|Object} $q\n\t * @param {angular.IRootScopeService|Object} $rootScope\n\t * @param {AbsyncProvider} absync\n\t * @param {Object} absyncNoopLog A log interface that does nothing.\n\t * @param {Object} absyncUncachedFilter A filter that mutates URLs so they will bypass the browser cache.\n\t * @returns {CacheService}\n\t * @ngInject\n\t */\n\tCacheService.$inject = [\"$http\", \"$injector\", \"$log\", \"$q\", \"$rootScope\", \"absync\", \"absyncNoopLog\", \"absyncUncachedFilter\"];\n\tfunction CacheService( $http, $injector, $log, $q, $rootScope, absync, absyncNoopLog, absyncUncachedFilter ) {\n\t\tvar self = this;\n\n\t\t// Retrieve a reference to the model of the collection that is being cached.\n\t\tvar _injector         = configuration.injector || $injector;\n\t\tvar _injectorHasModel = _injector.has( configuration.model );\n\t\tif( !_injectorHasModel ) {\n\t\t\tthrow new Error( \"Unable to construct the '\" + name + \"' service, because the referenced model '\" + configuration.model + \"' is not available for injection.\" );\n\t\t}\n\t\tvar _model = ( typeof configuration.model === \"string\" ) ? _injector.get( configuration.model ) : configuration.model;\n\n\t\t// Retrieve the serialization methods.\n\t\tvar serializeModel   = _model.serialize || configuration.serialize || serializationNoop;\n\t\tvar deserializeModel = _model.deserialize || configuration.deserialize || serializationNoop;\n\n\t\t// Store configuration.\n\t\tself.name          = name;\n\t\tself.configuration = configuration;\n\n\t\t// The entity cache must be constructed as an empty array or object, to allow the user to place watchers on it.\n\t\t// We must never replace the cache with a new array or object, we must always manipulate the existing one.\n\t\t// Otherwise watchers will not behave as the user expects them to.\n\t\t/* @type {Array<configuration.model>|configuration.model} */\n\t\tself.entityCache          = configuration.collectionName ? [] : {};\n\t\t// Create the ID -> entityIndex lookup table.\n\t\tself.entityCache.__lookup = {};\n\t\t// The raw cache is data that hasn't been deserialized and is used internally.\n\t\tself.__entityCacheRaw     = null;\n\n\t\t// Should request caching be used at all?\n\t\tself.enableRequestCache = true;\n\t\t// Cache requests made to the backend to avoid multiple, simultaneous requests for the same resource.\n\t\tself.__requestCache     = {};\n\t\t// When we make HTTP requests, the browser is generally allowed to cache the responses.\n\t\t// The server can control this behavior with cache control HTTPS headers.\n\t\t// However, at times it may be desirable to force the browser to always fetch fresh data from the backend.\n\t\t// This hash controls this behavior.\n\t\tself.allowBrowserCache = ( angular.merge || angular.extend )( {}, {\n\t\t\t// Should browser caching be allowed for initial cache sync operations?\n\t\t\tsync    : true,\n\t\t\t// Should browser caching be allowed when we retrieve single entities from the backend?\n\t\t\trequest : true\n\t\t}, configuration.allowBrowserCache );\n\t\tself.__uncached        = absyncUncachedFilter;\n\n\t\t// Use $http by default and expose it on the service.\n\t\t// This allows the user to set a different, possibly decorated, HTTP interface for this service.\n\t\tself.httpInterface = $http;\n\t\t// Do the same for our logger.\n\t\tself.logInterface  = configuration.debug ? $log : absyncNoopLog;\n\t\t// The scope on which we broadcast all our relevant events.\n\t\tself.scope         = configuration.scope || $rootScope;\n\t\t// Keep a reference to $q.\n\t\tself.q             = $q;\n\t\t// Keep a reference to absync itself.\n\t\tself.absync        = absync;\n\n\t\t// Prefix log messages with this string.\n\t\tself.logPrefix = \"absync:\" + name.toLocaleUpperCase() + \" \";\n\n\t\t// If enabled, entities received in response to a create or update API call, will be put into the cache.\n\t\t// Otherwise, absync will wait for them to be published through the websocket channel.\n\t\tself.forceEarlyCacheUpdate = configuration.forceEarlyCacheUpdate || false;\n\n\t\t// Throws failures so that they can be handled outside of absync.\n\t\tself.throwFailures = typeof configuration.throwFailures !== \"undefined\" ? configuration.throwFailures : true;\n\n\t\t// Expose the serializer/deserializer so that they can be adjusted at any time.\n\t\tself.serializer   = serializeModel;\n\t\tself.deserializer = deserializeModel;\n\n\t\t// Store a reference to the optional filter function.\n\t\tself.filter = configuration.filter;\n\n\t\t// Bind event handlers to this cache service, to ensure consistent this binding.\n\t\tself.__onEntityOnWebsocketBound     = self.__onEntityOnWebsocket.bind( self );\n\t\tself.__onCollectionOnWebsocketBound = self.__onCollectionOnWebsocket.bind( self );\n\t\tself.__onEntityReceivedBound        = self.__onEntityReceived.bind( self );\n\t\tself.__onCollectionReceivedBound    = self.__onCollectionReceived.bind( self );\n\n\t\t// Tell absync to register an event listener for both our entity and its collection.\n\t\t// When we receive these events, we broadcast an equal Angular event on the root scope.\n\t\t// This way the user can already peek at the data (manipulating it is discouraged though).\n\t\tabsync.on( configuration.entityName, self.__onEntityOnWebsocketBound );\n\t\tif( configuration.collectionName ) {\n\t\t\tabsync.on( configuration.collectionName, self.__onCollectionOnWebsocketBound );\n\t\t}\n\n\t\t// Now we listen on the root scope for the same events we're firing above.\n\t\t// This is where our own absync synchronization logic kicks in.\n\t\tself.__onEntityReceivedBound.unregister = self.scope.$on( configuration.entityName,\n\t\t\tself.__onEntityReceivedBound );\n\t\tif( configuration.collectionName ) {\n\t\t\tself.__onCollectionReceivedBound.unregister = self.scope.$on( configuration.collectionName,\n\t\t\t\tself.__onCollectionReceivedBound );\n\t\t}\n\n\t\tself.logInterface.info( self.logPrefix + \"service was instantiated.\" );\n\t}\n\n\t/**\n\t * Invoked when an entity is received on a websocket.\n\t * Translates the websocket event to an Angular event and broadcasts it on the scope.\n\t * @param {Object} message\n\t * @private\n\t */\n\tCacheService.prototype.__onEntityOnWebsocket = function CacheService$onEntityOnWebsocket( message ) {\n\t\tvar self = this;\n\t\tself.logInterface.debug( self.logPrefix + \"entity received\", message );\n\t\tself.scope.$broadcast( configuration.entityName, message[ configuration.entityName ] );\n\t};\n\n\t/**\n\t * Invoked when a collection is received on a websocket.\n\t * Translates the websocket event to an Angular event and broadcasts it on the scope.\n\t * @param {Object} message\n\t * @private\n\t */\n\tCacheService.prototype.__onCollectionOnWebsocket = function CacheService$onCollectionOnWebsocket( message ) {\n\t\tvar self = this;\n\t\tself.logInterface.debug( self.logPrefix + \"collection received\", message );\n\t\tself.scope.$broadcast( configuration.collectionName, message[ configuration.collectionName ] );\n\t};\n\n\t/**\n\t * Event handler for when the initial badge of raw data becomes available.\n\t * @param {Array<Object>|Object} rawData\n\t * @private\n\t */\n\tCacheService.prototype.__onDataAvailable = function CacheService$onDataAvailable( rawData ) {\n\t\tvar self = this;\n\n\t\tif( Array.isArray( self.entityCache ) ) {\n\t\t\t// The symbol self.entityCache is expected to be an empty array.\n\t\t\t// We initialize it in the constructor to an empty array and we don't expect any writes to have\n\t\t\t// happened to it. In case writes *did* happen, we assume that whoever wrote to it knows what\n\t\t\t// they're doing.\n\t\t\tangular.forEach( rawData[ configuration.collectionName ], deserializeCollectionEntry );\n\n\t\t\t// Notify the rest of the application about a fresh collection.\n\t\t\tself.scope.$broadcast( \"collectionNew\", {\n\t\t\t\tservice : self,\n\t\t\t\tcache   : self.entityCache\n\t\t\t} );\n\n\t\t} else {\n\t\t\tvar deserialized = self.deserializer( rawData[ configuration.entityName ] );\n\t\t\tself.__updateCacheWithEntity( deserialized );\n\t\t}\n\n\t\treturn self.entityCache;\n\n\t\tfunction deserializeCollectionEntry( rawEntity ) {\n\t\t\tvar entityToCache = self.deserializer( rawEntity );\n\t\t\tself.entityCache.push( entityToCache );\n\t\t\tif( self.entityCache.__lookup ) {\n\t\t\t\tself.entityCache.__lookup[ entityToCache.id ] = self.entityCache.length - 1;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Event handler for when an entity is received on the root scope.\n\t * @param {Object} event The event object.\n\t * @param {Object} args The raw object as it was read from the wire.\n\t * @return {Promise|undefined}\n\t * @private\n\t */\n\tCacheService.prototype.__onEntityReceived = function CacheService$onEntityReceived( event, args ) {\n\t\tvar self            = this;\n\t\tvar _entityReceived = args;\n\n\t\t// Sometimes you don't want to use an entity cache, and only listen to websocket events.\n\t\t// In this case you don't configure an entityUri and entityUri, so received entities will be emitted directly.\n\t\tif( configuration.collectionUri === null && configuration.entityUri === null ) {\n\n\t\t\tvar directResponse = {\n\t\t\t\tservice : self,\n\t\t\t\tcache   : self.entityCache,\n\t\t\t\tentity  : _entityReceived\n\t\t\t};\n\n\t\t\tself.scope.$broadcast( \"beforeEntityNew\", directResponse );\n\t\t\tself.scope.$broadcast( \"entityNew\", directResponse );\n\n\t\t\t//noinspection JSValidateTypes\n\t\t\treturn self.q.when();\n\t\t}\n\n\t\t// Check if our raw entity cache was even initialized.\n\t\t// It's possible that it isn't, because websocket updates can be received before any manual requests\n\t\t// were made to the backend.\n\t\tif( !self.__entityCacheRaw || !self.__entityCacheRaw[ configuration.collectionName || configuration.entityName ] ) {\n\t\t\t// We ignore this update and just stack a new read request on top of any existing ones.\n\t\t\t// This makes sure that we load the freshest entity in an orderly fashion and lose the state we received\n\t\t\t// here, as we're getting the latest version of the entity.\n\t\t\treturn self.ensureLoaded()\n\t\t\t\t.then( function updateEntity() {\n\t\t\t\t\treturn self.read( _entityReceived.id );\n\t\t\t\t} );\n\t\t}\n\n\t\t// Determine if the received record consists ONLY of an id property,\n\t\t// which would mean that this record was deleted from the backend.\n\t\tif( 1 === Object.keys( _entityReceived ).length && _entityReceived.hasOwnProperty( \"id\" ) ) {\n\t\t\tself.logInterface.info( self.logPrefix + \"Entity was deleted from the server. Updating cache…\" );\n\n\t\t\tself.__cacheMaintain( self.__entityCacheRaw[ configuration.collectionName || configuration.entityName ],\n\t\t\t\t_entityReceived,\n\t\t\t\t\"delete\",\n\t\t\t\tfalse );\n\n\t\t\treturn self.__removeEntityFromCache( _entityReceived.id );\n\n\t\t} else {\n\t\t\tself.logInterface.debug( self.logPrefix + \"Entity was updated on the server. Updating cache…\" );\n\n\t\t\tself.__cacheMaintain( self.__entityCacheRaw[ configuration.collectionName || configuration.entityName ],\n\t\t\t\t_entityReceived,\n\t\t\t\t\"update\",\n\t\t\t\tfalse );\n\n\t\t\treturn self.__updateCacheWithEntity( self.deserializer( _entityReceived ) );\n\t\t}\n\t};\n\n\t/**\n\t * Event handler for when a collection is received on the root scope.\n\t * @param {Object} event The event object.\n\t * @param {Array<Object>} args The raw collection as it was read from the wire.\n\t * @private\n\t */\n\tCacheService.prototype.__onCollectionReceived = function CacheService$onCollectionReceived( event, args ) {\n\t\tvar self                = this;\n\t\tvar _collectionReceived = args;\n\n\t\t// When we're receiving a full collection, all data we currently have in our cache is useless.\n\t\t// We reset the length of the array here, because assigning a new array would possibly conflict\n\t\t// with watchers placed on the original object.\n\t\tself.entityCache.length = 0;\n\n\t\t// Deserialize the received data and place the models in our cache.\n\t\tangular.forEach( _collectionReceived, addEntityToCache );\n\n\t\tfunction addEntityToCache( entityReceived ) {\n\t\t\tvar deserialized = self.deserializer( entityReceived );\n\t\t\tself.__updateCacheWithEntity( deserialized );\n\t\t}\n\t};\n\n\t/**\n\t * Ensure that the cached collection is retrieved from the server.\n\t * @param {Boolean} [forceReload=false] Should the data be loaded, even if the service already has a local cache?\n\t * @returns {Promise<Array<configuration.model>>|IPromise<Array>|IPromise<void>|Q.Promise<Array<configuration.model>>|angular.IPromise<TResult>}\n\t */\n\tCacheService.prototype.ensureLoaded = function CacheService$ensureLoaded( forceReload ) {\n\t\tvar self = this;\n\n\t\tforceReload = forceReload === true;\n\t\tif( forceReload ) {\n\t\t\tdelete self.__loading;\n\t\t}\n\n\t\tif( self.__loading ) {\n\t\t\treturn self.__loading;\n\t\t}\n\n\t\t// We only perform any loading, if we don't have raw data cached yet, or if we're forced.\n\t\tif( null === self.__entityCacheRaw || forceReload ) {\n\t\t\tif( !configuration.collectionName || !configuration.collectionUri ) {\n\t\t\t\tif( configuration.entityName && configuration.entityUri ) {\n\t\t\t\t\tself.__loading = self.httpInterface\n\t\t\t\t\t\t.get( self.allowBrowserCache.sync ? configuration.entityUri : self.__uncached(\n\t\t\t\t\t\t\tconfiguration.entityUri ) )\n\t\t\t\t\t\t.then( onSingleEntityReceived, onSingleEntityRetrievalFailure );\n\n\t\t\t\t} else {\n\t\t\t\t\t// If the user did not provide information necessary to work with a collection, immediately return\n\t\t\t\t\t// a promise for an empty collection. The user could still use read() to grab individual entities.\n\t\t\t\t\treturn self.q.when( [] );\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tself.logInterface.info( self.logPrefix + \"Retrieving '\" + configuration.collectionName + \"' collection…\" );\n\t\t\t\tself.__loading = self.httpInterface\n\t\t\t\t\t.get( self.allowBrowserCache.sync ? configuration.collectionUri : self.__uncached(\n\t\t\t\t\t\tconfiguration.collectionUri ) )\n\t\t\t\t\t.then( onCollectionReceived, onCollectionRetrievalFailure );\n\t\t\t}\n\n\t\t\treturn self.__loading;\n\t\t}\n\n\t\treturn self.q.when( self.entityCache );\n\n\t\t/**\n\t\t * Invoked when the collection was received from the server.\n\t\t * @param {angular.IHttpPromiseCallbackArg|Object} serverResponse The reply sent from the server.\n\t\t */\n\t\tfunction onCollectionReceived( serverResponse ) {\n\t\t\tif( !serverResponse.data[ configuration.collectionName ] ) {\n\t\t\t\tthrow new Error( \"The response from the server was not in the expected format. It should have a member named '\" + configuration.collectionName + \"'.\" );\n\t\t\t}\n\n\t\t\tself.__entityCacheRaw = serverResponse.data;\n\t\t\tself.entityCache.splice( 0, self.entityCache.length );\n\t\t\treturn self.__onDataAvailable( serverResponse.data );\n\t\t}\n\n\t\t/**\n\t\t * Invoked when there was an error while trying to retrieve the collection from the server.\n\t\t * @param {angular.IHttpPromiseCallbackArg|Object} serverResponse The reply sent from the server.\n\t\t */\n\t\tfunction onCollectionRetrievalFailure( serverResponse ) {\n\t\t\tself.logInterface.error( self.logPrefix + \"Unable to retrieve the collection from the server.\",\n\t\t\t\tserverResponse );\n\t\t\tself.__entityCacheRaw = null;\n\n\t\t\tself.scope.$emit( \"absyncError\", serverResponse );\n\n\t\t\tif( self.throwFailures ) {\n\t\t\t\tthrow serverResponse;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Invoked when the entity was received from the server.\n\t\t * @param {angular.IHttpPromiseCallbackArg|Object} serverResponse The reply sent from the server.\n\t\t */\n\t\tfunction onSingleEntityReceived( serverResponse ) {\n\t\t\tif( !serverResponse.data[ configuration.entityName ] ) {\n\t\t\t\tthrow new Error( \"The response from the server was not in the expected format. It should have a member named '\" + configuration.entityName + \"'.\" );\n\t\t\t}\n\n\t\t\tself.__entityCacheRaw = serverResponse.data;\n\t\t\tself.__onDataAvailable( serverResponse.data );\n\t\t}\n\n\t\t/**\n\t\t * Invoked when there was an error while trying to retrieve the entity from the server.\n\t\t * @param {angular.IHttpPromiseCallbackArg|Object} serverResponse The reply sent from the server.\n\t\t */\n\t\tfunction onSingleEntityRetrievalFailure( serverResponse ) {\n\t\t\tself.logInterface.error( self.logPrefix + \"Unable to retrieve the entity from the server.\",\n\t\t\t\tserverResponse );\n\t\t\tself.__entityCacheRaw = null;\n\n\t\t\tself.scope.$emit( \"absyncError\", serverResponse );\n\n\t\t\tif( self.throwFailures ) {\n\t\t\t\tthrow serverResponse;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Pre-seed the cache with the given value.\n\t * Usually, you'd want to follow this up with a sync() to get fully in sync with the backend.\n\t * @param {Object|Array<Object>} cache\n\t * @returns {CacheService}\n\t */\n\tCacheService.prototype.seed = function CacheService$seed( cache ) {\n\t\tvar self              = this;\n\t\tself.__entityCacheRaw = cache;\n\n\t\treturn self.__onDataAvailable( self.__entityCacheRaw );\n\t};\n\n\t/**\n\t * Insert a phantom into the cache, if no real entity with the same ID exists yet.\n\t * Phantoms bypass the raw entity cache.\n\t * @param {Object} entity\n\t * @param {Number} [timeout] How long to wait for the phantom to be replaced.\n\t * If no timeout is defined, the replacement of the phantom is ignored.\n\t * To wait forever for the phantom to be replaced, set `timeout` to Number.POSITIVE_INFINITY or `null`.\n\t * @return {Promise<Object>} Resolved when the phantom is replaced by the actual entity; rejected after the timeout.\n\t */\n\tCacheService.prototype.phantom = function CacheService$phantom( entity, timeout ) {\n\t\tvar self = this;\n\n\t\tif( self.has( entity.id ) ) {\n\t\t\treturn self.read( entity.id );\n\t\t}\n\n\t\ttimeout = timeout === null ? Number.POSITIVE_INFINITY : timeout;\n\t\ttimeout = typeof timeout === \"undefined\" ? null : timeout;\n\n\t\t//noinspection JSValidateTypes\n\t\treturn self.q.when( self.__onEntityReceived( null, entity ) )\n\t\t\t.then( function onPhantomRegistered() {\n\t\t\t\treturn new self.q( function resolver( resolve, reject ) {\n\n\t\t\t\t\tif( timeout === null ) {\n\t\t\t\t\t\t// The user did not want to wait for the replacement.\n\t\t\t\t\t\treturn resolve( entity );\n\t\t\t\t\t}\n\n\t\t\t\t\tvar removeTimeout  = null;\n\t\t\t\t\tvar removeListener = null;\n\n\t\t\t\t\tif( timeout < Number.POSITIVE_INFINITY ) {\n\t\t\t\t\t\tremoveTimeout = setTimeout( function abortWaiting() {\n\t\t\t\t\t\t\tif( removeListener ) {\n\t\t\t\t\t\t\t\tremoveListener();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treject( new Error( \"Phantom was not replaced in time.\" ) );\n\t\t\t\t\t\t}, timeout );\n\t\t\t\t\t}\n\n\t\t\t\t\tremoveListener = self.scope.$on( \"entityUpdated\", function onEntityUpdated( event, args ) {\n\t\t\t\t\t\tif( args.entity.id === entity.id ) {\n\t\t\t\t\t\t\tremoveListener();\n\t\t\t\t\t\t\tclearTimeout( removeTimeout );\n\n\t\t\t\t\t\t\tremoveListener = null;\n\t\t\t\t\t\t\tremoveTimeout  = null;\n\n\t\t\t\t\t\t\tresolve( args.entity );\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\t\t\t} );\n\t\t\t} );\n\t};\n\n\t/**\n\t * Drop existing cache and force reload.\n\t * @returns {Promise.<Array.<configuration.model>>|IPromise.<Array>|IPromise.<void>|Q.Promise.<Array.<configuration.model>>|angular.IPromise.<TResult>}\n\t */\n\tCacheService.prototype.sync = function CacheService$sync() {\n\t\tvar self = this;\n\n\t\tself.__entityCacheRaw = null;\n\n\t\treturn self.ensureLoaded( true );\n\t};\n\n\t/**\n\t * Check if the given element with the given ID is in the cache.\n\t * @param {String} id\n\t * @return {Boolean} true if the element is in the cache; false otherwise.\n\t */\n\tCacheService.prototype.has = function CacheService$has( id ) {\n\t\tvar self = this;\n\n\t\treturn self.entityCache.__lookup.hasOwnProperty( id );\n\t};\n\n\t/**\n\t * Read a single entity from the cache, or load it from the server if required.\n\t * The entity will be placed into the cache.\n\t * @param {String} id The ID of the entity to retrieve.\n\t * @param {Boolean} [forceReload=false] Should the entity be retrieved from the server, even if it is already in the cache?\n\t * @returns {Promise<configuration.model>|IPromise<TResult>|IPromise<void>|angular.IPromise<TResult>}\n\t */\n\tCacheService.prototype.read = function CacheService$read( id, forceReload ) {\n\t\tvar self = this;\n\n\t\tforceReload = forceReload === true;\n\n\t\tself.logInterface.debug( self.logPrefix + \"Requesting entity '\" + id + \"' (forceReload:\" + forceReload + \")…\" );\n\n\t\tif( !forceReload ) {\n\t\t\tvar entityIndex = 0;\n\n\t\t\t// Check if the entity is in the cache and return instantly if found.\n\t\t\tif( self.entityCache.__lookup ) {\n\t\t\t\tentityIndex = self.entityCache.__lookup.hasOwnProperty( id ) ? self.entityCache.__lookup[ id ] : self.entityCache.length;\n\t\t\t}\n\n\t\t\tfor( var entity = self.entityCache[ entityIndex ];\n\t\t\t     entityIndex < self.entityCache.length;\n\t\t\t     ++entityIndex, entity = self.entityCache[ entityIndex ] ) {\n\t\t\t\tif( entity.id === id ) {\n\t\t\t\t\tself.logInterface.debug( self.logPrefix + \"Requested entity  '\" + id + \"' is served from cache.\" );\n\t\t\t\t\treturn self.q.when( entity );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tself.logInterface.debug( self.logPrefix + \"Requested entity  '\" + id + \"' is fetched from backend.\" );\n\n\t\treturn self.__requestEntity( id )\n\t\t\t.then( onEntityRetrieved, onEntityRetrievalFailure );\n\n\t\t/**\n\t\t * Invoked when the entity was retrieved from the server.\n\t\t * @param {angular.IHttpPromiseCallbackArg|Object} serverResponse The reply sent from the server.\n\t\t */\n\t\tfunction onEntityRetrieved( serverResponse ) {\n\t\t\tif( !serverResponse.data[ configuration.entityName ] ) {\n\t\t\t\tthrow new Error( \"The response from the server was not in the expected format. It should have a member named '\" + configuration.entityName + \"'.\" );\n\t\t\t}\n\n\t\t\tvar rawEntity = serverResponse.data[ configuration.entityName ];\n\n\t\t\t// Put the raw entity into our raw entity cache.\n\t\t\t// We keep the raw copy to allow caching of the raw data.\n\t\t\tself.__cacheMaintain( self.__entityCacheRaw[ configuration.collectionName || configuration.entityName ],\n\t\t\t\trawEntity,\n\t\t\t\t\"update\",\n\t\t\t\tfalse );\n\n\t\t\t// Deserialize the object and place it into the cache.\n\t\t\t// We do not need to check here if the object already exists in the cache.\n\t\t\t// While it could be possible that the same entity is retrieved multiple times, __updateCacheWithEntity\n\t\t\t// will not insert duplicates into the cache.\n\t\t\tvar deserialized = self.deserializer( rawEntity );\n\t\t\tself.__updateCacheWithEntity( deserialized );\n\t\t\treturn deserialized;\n\t\t}\n\n\t\t/**\n\t\t * Invoked when there was an error while trying to retrieve the entity from the server.\n\t\t * @param {angular.IHttpPromiseCallbackArg|Object} serverResponse The reply sent from the server.\n\t\t */\n\t\tfunction onEntityRetrievalFailure( serverResponse ) {\n\t\t\tself.logInterface.error( self.logPrefix + \"Unable to retrieve entity with ID '\" + id + \"' from the server.\",\n\t\t\t\tserverResponse );\n\t\t\tself.scope.$emit( \"absyncError\", serverResponse );\n\n\t\t\tif( self.throwFailures ) {\n\t\t\t\tthrow serverResponse;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Request an entity from the backend.\n\t * @param {String} id The ID of the entity.\n\t * @returns {Promise<configuration.model>|IPromise<TResult>|IPromise<void>|angular.IPromise<TResult>}\n\t * @private\n\t */\n\tCacheService.prototype.__requestEntity = function CacheService$requestEntity( id ) {\n\t\tvar self = this;\n\n\t\tif( self.enableRequestCache && self.__requestCache && self.__requestCache[ id ] ) {\n\t\t\tself.logInterface.debug( self.logPrefix + \"Entity request    '\" + id + \"' served from request cache.\" );\n\t\t\treturn self.__requestCache[ id ];\n\t\t}\n\n\t\t// Make sure our raw entity cache exists.\n\t\tself.__entityCacheRaw                                 = self.__entityCacheRaw || {};\n\t\tself.__entityCacheRaw[ configuration.collectionName ] = self.__entityCacheRaw[ configuration.collectionName ] || [];\n\n\t\tvar requestUri = configuration.entityUri + ( id ? ( \"/\" + id ) : \"\" );\n\n\t\t// Grab the entity from the backend.\n\t\tvar request = self.httpInterface\n\t\t\t.get( self.allowBrowserCache.request ? requestUri : self.__uncached( requestUri ) )\n\t\t\t.then( removeRequestFromCache.bind( self, id ) );\n\n\t\tif( self.enableRequestCache && self.__requestCache ) {\n\t\t\tself.__requestCache[ id ] = request;\n\t\t}\n\n\t\treturn request;\n\n\t\tfunction removeRequestFromCache( id, serverResponse ) {\n\t\t\tdelete self.__requestCache[ id ];\n\t\t\treturn serverResponse;\n\t\t}\n\t};\n\n\t/**\n\t * Updates an entity and persists it to the backend and the cache.\n\t * @param {configuration.model} entity\n\t * @param {Boolean} [returnResult=false] Should the result of the query be returned?\n\t * @return {Promise<configuration.model>|IPromise<TResult>|angular.IPromise<TResult>} A promise that will be resolved with the updated entity.\n\t */\n\tCacheService.prototype.update = function CacheService$update( entity, returnResult ) {\n\t\tvar self = this;\n\n\t\treturnResult = returnResult || false;\n\n\t\t// First create a copy of the object, which has complex properties reduced to their respective IDs.\n\t\tvar reduced    = self.reduceComplex( entity );\n\t\t// Now serialize the object.\n\t\tvar serialized = self.serializer( reduced );\n\n\t\t// Wrap the entity in a new object, with a single property, named after the entity type.\n\t\tvar wrappedEntity                         = {};\n\t\twrappedEntity[ configuration.entityName ] = serialized;\n\n\t\t// Check if the entity has an \"id\" property, if it has, we will update. Otherwise, we create.\n\t\tif( \"undefined\" !== typeof entity.id ) {\n\t\t\treturn self.httpInterface\n\t\t\t\t.put( configuration.entityUri + \"/\" + entity.id, wrappedEntity )\n\t\t\t\t.then( afterEntityStored.bind( self, returnResult ), onEntityStorageFailure.bind( self ) );\n\n\t\t} else {\n\t\t\t// Create a new entity\n\t\t\treturn self.httpInterface\n\t\t\t\t.post( configuration.collectionUri, wrappedEntity )\n\t\t\t\t.then( afterEntityStored.bind( self, returnResult ), onEntityStorageFailure.bind( self ) );\n\t\t}\n\t};\n\n\tCacheService.prototype.patch = function CacheService$patch( entity, returnResult ) {\n\t\tvar self = this;\n\n\t\treturnResult = returnResult || false;\n\n\t\t// First create a copy of the object, which has complex properties reduced to their respective IDs.\n\t\tvar reduced    = self.reduceComplex( entity );\n\t\t// Now serialize the object.\n\t\tvar serialized = self.serializer( reduced );\n\n\t\t// Wrap the entity in a new object, with a single property, named after the entity type.\n\t\tvar wrappedEntity                         = {};\n\t\twrappedEntity[ configuration.entityName ] = serialized;\n\n\t\t// Check if the entity has an \"id\" property, if it has, we will update. Otherwise, we create.\n\t\tif( \"undefined\" !== typeof entity.id ) {\n\t\t\treturn self.httpInterface\n\t\t\t\t.patch( configuration.entityUri + \"/\" + entity.id, wrappedEntity )\n\t\t\t\t.then( afterEntityStored.bind( self, returnResult ), onEntityStorageFailure.bind( self ) );\n\n\t\t} else {\n\t\t\tthrow new Error( \"Attempted to patch an entity that was never stored on the server.\" );\n\t\t}\n\t};\n\n\t/**\n\t * Creates a new entity and persists it to the backend and the cache.\n\t */\n\tCacheService.prototype.create = CacheService.prototype.update;\n\n\t/**\n\t * Invoked when the entity was stored on the server.\n\t * @param {Boolean} returnResult Should we return the parsed entity that is contained in the response?\n\t * @param {angular.IHttpPromiseCallbackArg|Object} serverResponse The reply sent from the server.\n\t */\n\tfunction afterEntityStored( returnResult, serverResponse ) {\n\t\tvar self = this;\n\n\t\t// Writing an entity to the backend will usually invoke an update event to be\n\t\t// broadcast over websockets, where we would also retrieve the updated record.\n\t\t// We still put the updated record we receive here into the cache to ensure early consistency, if that is requested.\n\t\tif( !returnResult && !self.forceEarlyCacheUpdate ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif( serverResponse.data[ configuration.entityName ] ) {\n\t\t\tvar rawEntity = serverResponse.data[ configuration.entityName ];\n\t\t\t// If early cache updates are forced, put the return entity into the cache.\n\t\t\tif( self.forceEarlyCacheUpdate ) {\n\t\t\t\tvar newEntity = self.deserializer( rawEntity );\n\t\t\t\tself.__updateCacheWithEntity( newEntity );\n\n\t\t\t\tif( returnResult ) {\n\t\t\t\t\treturn newEntity;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( returnResult ) {\n\t\t\t\treturn rawEntity;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Invoked when there was an error while trying to store the entity on the server.\n\t * @param {angular.IHttpPromiseCallbackArg|Object} serverResponse The reply sent from the server.\n\t */\n\tfunction onEntityStorageFailure( serverResponse ) {\n\t\tvar self = this;\n\n\t\tself.logInterface.error( self.logPrefix + \"Unable to store entity on the server.\",\n\t\t\tserverResponse );\n\t\tself.logInterface.error( serverResponse );\n\t\tself.scope.$emit( \"absyncError\", serverResponse );\n\n\t\tif( self.throwFailures ) {\n\t\t\tthrow serverResponse;\n\t\t}\n\t}\n\n\t/**\n\t * Remove an entity from the cache and have it deleted on the backend.\n\t * @param {Object} entity\n\t */\n\tCacheService.prototype.delete = function CacheService$delete( entity ) {\n\t\tvar self = this;\n\n\t\tvar entityId = entity.id;\n\t\treturn self.httpInterface\n\t\t\t.delete( configuration.entityUri + \"/\" + entityId )\n\t\t\t.then( onEntityDeleted )\n\t\t\t.catch( onEntityDeletionFailed );\n\n\t\t/**\n\t\t * Invoked when the entity was successfully deleted from the server.\n\t\t * @param {angular.IHttpPromiseCallbackArg|Object} serverResponse The reply sent from the server.\n\t\t */\n\t\tfunction onEntityDeleted( serverResponse ) {\n\t\t\tself.__cacheMaintain( self.__entityCacheRaw[ configuration.collectionName || configuration.entityName ],\n\t\t\t\tentity,\n\t\t\t\t\"delete\",\n\t\t\t\tfalse );\n\n\t\t\treturn self.__removeEntityFromCache( entityId );\n\t\t}\n\n\t\t/**\n\t\t * Invoked when there was an error while trying to delete the entity from the server.\n\t\t * @param {angular.IHttpPromiseCallbackArg|Object} serverResponse The reply sent from the server.\n\t\t */\n\t\tfunction onEntityDeletionFailed( serverResponse ) {\n\t\t\tself.logInterface.error( serverResponse.data );\n\t\t\tself.scope.$emit( \"absyncError\", serverResponse );\n\n\t\t\tif( self.throwFailures ) {\n\t\t\t\tthrow serverResponse;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Put an entity into the cache or update the existing record if the entity was already in the cache.\n\t * @param {Object} entityToCache\n\t * @private\n\t */\n\tCacheService.prototype.__updateCacheWithEntity = function CacheService$updateCacheWithEntity( entityToCache ) {\n\t\tvar self = this;\n\n\t\tself.logInterface.info( self.logPrefix + \"Updating entity '\" + ( entityToCache.id || self.name ) + \"' in cache…\",\n\t\t\tentityToCache );\n\n\t\treturn self.__cacheMaintain( self.entityCache, entityToCache, \"update\", true );\n\t};\n\n\t/**\n\t * Perform maintenance operations on a cache.\n\t * @param cache The cache to operate on.\n\t * @param entityToCache The entity that the operation is relating to.\n\t * @param {String} operation The operation to perform.\n\t * @param {Boolean} [emit=false] Should appropriate absync events be broadcast to notify other actors?\n\t * @private\n\t */\n\tCacheService.prototype.__cacheMaintain = function CacheService$cacheMaintain( cache, entityToCache, operation, emit ) {\n\t\tvar self = this;\n\n\t\tvar entityIndex = 0;\n\t\tvar entity      = cache[ entityIndex ];\n\n\t\tif( self.filter ) {\n\t\t\tif( !self.filter( entityToCache ) ) {\n\t\t\t\tself.logInterface.info( self.logPrefix + \"Entity '\" + ( entityToCache.id || self.name ) + \"' was filtered.\",\n\t\t\t\t\tentityToCache );\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif( cache.__lookup ) {\n\t\t\tentityIndex = cache.__lookup.hasOwnProperty( entityToCache.id ) ? cache.__lookup[ entityToCache.id ] : cache.length;\n\t\t\tentity      = cache[ entityIndex ];\n\t\t}\n\n\t\tswitch( operation ) {\n\t\t\tcase \"update\":\n\t\t\t\tif( !Array.isArray( cache ) ) {\n\t\t\t\t\tif( emit ) {\n\t\t\t\t\t\t// Allow the user to intervene in the update process, before updating the entity.\n\t\t\t\t\t\tself.scope.$broadcast( \"beforeEntityUpdated\",\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tservice : self,\n\t\t\t\t\t\t\t\tcache   : cache,\n\t\t\t\t\t\t\t\tentity  : cache,\n\t\t\t\t\t\t\t\tupdated : entityToCache\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\n\t\t\t\t\tif( typeof cache.copyFrom === \"function\" ) {\n\t\t\t\t\t\tcache.copyFrom( entityToCache );\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tangular.extend( cache, entityToCache );\n\t\t\t\t\t}\n\n\t\t\t\t\t// After updating the entity, send another event to allow the user to react.\n\t\t\t\t\tself.scope.$broadcast( \"entityUpdated\",\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tservice : self,\n\t\t\t\t\t\t\tcache   : cache,\n\t\t\t\t\t\t\tentity  : cache\n\t\t\t\t\t\t} );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar found = false;\n\t\t\t\tfor( angular.noop; entityIndex < cache.length; ++entityIndex, entity = cache[ entityIndex ] ) {\n\t\t\t\t\tif( entity.id === entityToCache.id ) {\n\t\t\t\t\t\tif( emit ) {\n\t\t\t\t\t\t\t// Allow the user to intervene in the update process, before updating the entity.\n\t\t\t\t\t\t\tself.scope.$broadcast( \"beforeEntityUpdated\",\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tservice : self,\n\t\t\t\t\t\t\t\t\tcache   : cache,\n\t\t\t\t\t\t\t\t\tentity  : cache[ entityIndex ],\n\t\t\t\t\t\t\t\t\tupdated : entityToCache\n\t\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Use the \"copyFrom\" method on the entity, if it exists, otherwise use naive approach.\n\t\t\t\t\t\tvar targetEntity = cache[ entityIndex ];\n\t\t\t\t\t\tif( typeof targetEntity.copyFrom === \"function\" ) {\n\t\t\t\t\t\t\ttargetEntity.copyFrom( entityToCache );\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tangular.extend( targetEntity, entityToCache );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfound = true;\n\n\t\t\t\t\t\tif( emit ) {\n\t\t\t\t\t\t\t// After updating the entity, send another event to allow the user to react.\n\t\t\t\t\t\t\tself.scope.$broadcast( \"entityUpdated\",\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tservice : self,\n\t\t\t\t\t\t\t\t\tcache   : cache,\n\t\t\t\t\t\t\t\t\tentity  : cache[ entityIndex ]\n\t\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If the entity wasn't found in our records, it's a new entity.\n\t\t\t\tif( !found ) {\n\t\t\t\t\tif( emit ) {\n\t\t\t\t\t\tself.scope.$broadcast( \"beforeEntityNew\", {\n\t\t\t\t\t\t\tservice : self,\n\t\t\t\t\t\t\tcache   : cache,\n\t\t\t\t\t\t\tentity  : entityToCache\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\n\t\t\t\t\tcache.push( entityToCache );\n\t\t\t\t\tif( cache.__lookup ) {\n\t\t\t\t\t\tcache.__lookup[ entityToCache.id ] = cache.length - 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif( emit ) {\n\t\t\t\t\t\tself.scope.$broadcast( \"entityNew\", {\n\t\t\t\t\t\t\tservice : self,\n\t\t\t\t\t\t\tcache   : cache,\n\t\t\t\t\t\t\tentity  : entityToCache\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"delete\":\n\t\t\t\t// The \"delete\" operation is not expected to happen for single cached entities.\n\t\t\t\tfor( angular.noop; entityIndex < cache.length; ++entityIndex, entity = cache[ entityIndex ] ) {\n\t\t\t\t\tif( entity.id === entityToCache.id ) {\n\t\t\t\t\t\tif( emit ) {\n\t\t\t\t\t\t\t// Before removing the entity, allow the user to react.\n\t\t\t\t\t\t\tself.scope.$broadcast( \"beforeEntityRemoved\", {\n\t\t\t\t\t\t\t\tservice : self,\n\t\t\t\t\t\t\t\tcache   : cache,\n\t\t\t\t\t\t\t\tentity  : entity\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Remove the entity from the cache.\n\t\t\t\t\t\tcache.splice( entityIndex, 1 );\n\n\t\t\t\t\t\tif( cache.__lookup ) {\n\t\t\t\t\t\t\tdelete cache.__lookup[ entityToCache.id ];\n\n\t\t\t\t\t\t\tfor( var cacheEntry in cache.__lookup ) {\n\t\t\t\t\t\t\t\tif( entityIndex <= cache.__lookup[ cacheEntry ] ) {\n\t\t\t\t\t\t\t\t\t--cache.__lookup[ cacheEntry ];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif( emit ) {\n\t\t\t\t\t\t\t// Send another event to allow the user to take note of the removal.\n\t\t\t\t\t\t\tself.scope.$broadcast( \"entityRemoved\", {\n\t\t\t\t\t\t\t\tservice : self,\n\t\t\t\t\t\t\t\tcache   : cache,\n\t\t\t\t\t\t\t\tentity  : entity\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t};\n\n\t/**\n\t * Removes an entity from the internal cache. The entity is not removed from the backend.\n\t * @param {String} id The ID of the entity to remove from the cache.\n\t * @private\n\t */\n\tCacheService.prototype.__removeEntityFromCache = function CacheService$removeEntityFromCache( id ) {\n\t\tvar self = this;\n\n\t\treturn self.__cacheMaintain( self.entityCache, {\n\t\t\tid : id\n\t\t}, \"delete\", true );\n\t};\n\n\t/**\n\t * Retrieve an associative array of all cached entities, which uses the ID of the entity records as the key in the array.\n\t * This is a convenience method that is not utilized internally.\n\t * @returns {Array<configuration.model>}\n\t */\n\tCacheService.prototype.lookupTableById = function CacheService$lookupTableById() {\n\t\tvar self = this;\n\n\t\tvar lookupTable = [];\n\t\tfor( var entityIndex = 0;\n\t\t     entityIndex < self.entityCache.length;\n\t\t     ++entityIndex ) {\n\t\t\tlookupTable[ self.entityCache[ entityIndex ].id ] = self.entityCache[ entityIndex ];\n\t\t}\n\t\treturn lookupTable;\n\t};\n\n\t/**\n\t * Reduce instances of complex types within an entity with their respective IDs.\n\t * Note that no type checks are being performed. Every nested object with an \"id\" property is treated as a complex type.\n\t * @param {Object} entity The entity that should have its complex member reduced.\n\t * @param {Boolean} [arrayInsteadOfObject=false] true if the manipulated entity is an array; false if it's an object.\n\t * @returns {Object|Array} A copy of the input entity, with complex type instances replaced with their respective ID.\n\t */\n\tCacheService.prototype.reduceComplex = function CacheService$reduceComplex( entity, arrayInsteadOfObject ) {\n\t\tvar self = this;\n\n\t\tvar result = arrayInsteadOfObject ? [] : {};\n\t\tfor( var propertyName in entity ) {\n\t\t\tif( !entity.hasOwnProperty( propertyName ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Recurse for nested arrays.\n\t\t\tif( Array.isArray( entity[ propertyName ] ) ) {\n\t\t\t\tresult[ propertyName ] = self.reduceComplex( entity[ propertyName ], true );\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Replace complex type with its ID.\n\t\t\tif( entity[ propertyName ] && entity[ propertyName ].id ) {\n\t\t\t\tresult[ propertyName ] = entity[ propertyName ].id;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Just copy over the plain property.\n\t\t\tresult[ propertyName ] = entity[ propertyName ];\n\t\t}\n\t\treturn result;\n\t};\n\n\t/**\n\t * Populate references to complex types in an instance.\n\t * @param {Object} entity The entity that should be manipulated.\n\t * @param {String} propertyName The name of the property of entity which should be populated.\n\t * @param {CacheService} cache An instance of another caching service that can provide the complex\n\t * type instances which are being referenced in entity.\n\t * @param {Object|Boolean} [options] A hash with options relating to the population process.\n\t * @param {Boolean} [options.force=false] If true, all complex types will be replaced with references to the\n\t * instances in cache; otherwise, only properties that are string representations of complex type IDs will be replaced.\n\t * @param {Boolean} [options.crossLink=false] If true, the entity will also be put into a relating property in the\n\t * foreign entity.\n\t * @param {String} [options.crossLinkProperty] The name of the property in the foreign type into which the entity\n\t * should be cross-linked.\n\t * @returns {IPromise<TResult>|IPromise<any[]>|IPromise<{}>|angular.IPromise<TResult>}\n\t */\n\tCacheService.prototype.populateComplex = function CacheService$populateComplex( entity, propertyName, cache, options ) {\n\t\tvar self = this;\n\n\t\toptions = options || {};\n\t\tif( typeof options === \"boolean\" ) {\n\t\t\tself.logInterface.warn( \"Argument 'force' is deprecated. Provide an options hash instead.\" );\n\t\t\toptions = {\n\t\t\t\tforce : options\n\t\t\t};\n\t\t}\n\t\toptions.force             = options.force || false;\n\t\toptions.crossLink         = options.crossLink || false;\n\t\toptions.crossLinkProperty = options.crossLinkProperty || \"\";\n\n\t\tif( options.crossLink && !options.crossLinkProperty ) {\n\t\t\tself.logInterface.warn(\n\t\t\t\t\"Option 'crossLink' given without 'crossLinkProperty'. Cross-linking will be disabled.\" );\n\t\t\toptions.crossLink = false;\n\t\t}\n\n\t\t// If the target property is an array, ...\n\t\tif( Array.isArray( entity[ propertyName ] ) ) {\n\t\t\t// ...map the elements in the array to promises.\n\t\t\tvar promises = entity[ propertyName ].map( mapElementToPromise );\n\n\t\t\treturn self.q.all( promises );\n\n\t\t} else {\n\t\t\tif( entity[ propertyName ] === null ) {\n\t\t\t\treturn self.q.when( null )\n\t\t\t\t\t.then( onComplexRetrieved );\n\t\t\t}\n\n\t\t\t// We usually assume the properties to be strings (the ID of the referenced complex).\n\t\t\tif( typeof entity[ propertyName ] !== \"string\" ) {\n\t\t\t\t// If \"force\" is enabled, we check if this non-string property is an object and has an \"id\" member, which is a string.\n\t\t\t\tif( options.force && typeof entity[ propertyName ] === \"object\" && typeof entity[ propertyName ].id === \"string\" ) {\n\t\t\t\t\t// If that is true, then we replace the whole object with the ID and continue as usual.\n\t\t\t\t\tentity[ propertyName ] = entity[ propertyName ].id;\n\n\t\t\t\t} else {\n\t\t\t\t\tif( self.throwFailures ) {\n\t\t\t\t\t\tthrow new Error( \"The referenced entity did not have an 'id' property that would be expected.\" );\n\t\t\t\t\t}\n\t\t\t\t\treturn self.q.when( false );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Treat the property as an ID and read the complex with that ID from the cache.\n\t\t\treturn cache.read( entity[ propertyName ] )\n\t\t\t\t.then( onComplexRetrieved );\n\t\t}\n\n\t\tfunction mapElementToPromise( element, index ) {\n\t\t\t// We usually assume the properties to be strings (the ID of the referenced complex).\n\t\t\tif( typeof entity[ propertyName ][ index ] !== \"string\" ) {\n\t\t\t\t// If \"force\" is enabled, we check if this non-string property is an object and has an \"id\" member, which is a string.\n\t\t\t\tif( options.force && typeof entity[ propertyName ][ index ] === \"object\" && typeof entity[ propertyName ][ index ].id === \"string\" ) {\n\t\t\t\t\t// If that is true, then we replace the whole object with the ID and continue as usual.\n\t\t\t\t\tentity[ propertyName ][ index ] = entity[ propertyName ][ index ].id;\n\n\t\t\t\t} else {\n\t\t\t\t\tif( self.throwFailures ) {\n\t\t\t\t\t\tthrow new Error( \"The referenced entity did not have an 'id' property that would be expected.\" );\n\t\t\t\t\t}\n\n\t\t\t\t\treturn self.q.when( false );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Treat the property as an ID and read the complex with that ID from the cache.\n\t\t\treturn cache.read( entity[ propertyName ][ index ] )\n\t\t\t\t.then( onComplexRetrieved );\n\n\t\t\tfunction onComplexRetrieved( complex ) {\n\t\t\t\t// When the complex was retrieved, store it back into the array.\n\t\t\t\tentity[ propertyName ][ index ] = complex;\n\n\t\t\t\tif( options.crossLink ) {\n\t\t\t\t\tcrossLink( complex, entity );\n\t\t\t\t}\n\n\t\t\t\treturn entity;\n\t\t\t}\n\t\t}\n\n\t\tfunction onComplexRetrieved( complex ) {\n\t\t\t// When the complex was retrieved, store it back into the entity.\n\t\t\tentity[ propertyName ] = complex;\n\n\t\t\tif( options.crossLink ) {\n\t\t\t\tcrossLink( complex, entity );\n\t\t\t}\n\n\t\t\treturn entity;\n\t\t}\n\n\t\tfunction crossLink( complex, entity ) {\n\t\t\t// If cross-linking is enabled, put our entity into the foreign complex.\n\t\t\tif( Array.isArray( complex[ options.crossLinkProperty ] ) ) {\n\t\t\t\t// Check if the ID exists in the array.\n\t\t\t\tvar idIndex = complex[ options.crossLinkProperty ].indexOf( entity.id );\n\t\t\t\tif( -1 < idIndex ) {\n\t\t\t\t\t// Replace the ID with the entity.\n\t\t\t\t\tcomplex[ options.crossLinkProperty ][ idIndex ] = entity;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Check if the entity is already linked into the array.\n\t\t\t\tfor( var lookupIndex = 0, lookupEntity = complex[ options.crossLinkProperty ][ 0 ];\n\t\t\t\t     lookupIndex < complex[ options.crossLinkProperty ].length;\n\t\t\t\t     ++lookupIndex, lookupEntity = complex[ options.crossLinkProperty ][ lookupIndex ] ) {\n\t\t\t\t\t// Check if the exact same reference is already within the array.\n\t\t\t\t\tif( lookupEntity === entity ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check if another element with the same ID already exists in the array.\n\t\t\t\t\tif( lookupEntity.id === entity.id ) {\n\t\t\t\t\t\tcomplex[ options.crossLinkProperty ][ lookupIndex ] = entity;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Just push the element into the array.\n\t\t\t\tcomplex[ options.crossLinkProperty ].push( entity );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcomplex[ options.crossLinkProperty ] = entity;\n\t\t}\n\t};\n\n\t/**\n\t * Reset the state of the cache service to when it was first instantiated.\n\t * Assumes that the configuration was not touched.\n\t * This method is primarily targeted at testing, but can be useful in production as well.\n\t */\n\tCacheService.prototype.reset = function CacheService$reset() {\n\t\tvar self = this;\n\n\t\tself.entityCache          = self.configuration.collectionName ? [] : {};\n\t\tself.entityCache.__lookup = self.entityCache.__lookup || {};\n\n\t\tself.__entityCacheRaw = null;\n\t\tself.__requestCache   = {};\n\t};\n\n\tCacheService.prototype.teardown = function CacheService$teardown() {\n\t\tvar self = this;\n\n\t\tself.absync.off( self.__onEntityOnWebsocketBound );\n\t\tself.absync.off( self.__onCollectionOnWebsocketBound );\n\n\t\tif( self.__onEntityReceivedBound.unregister ) {\n\t\t\tself.__onEntityReceivedBound.unregister();\n\t\t}\n\t\tif( self.__onCollectionReceivedBound.unregister ) {\n\t\t\tself.__onCollectionReceivedBound.unregister();\n\t\t}\n\t};\n\n\treturn CacheService;\n}\n\nfunction serializationNoop( model ) {\n\treturn model;\n}\n}());;(function() {\n\"use strict\";\n/* globals angular */\n\nangular\n\t.module( \"absync\" )\n\t.service( \"AbsyncServiceConfiguration\", AbsyncServiceConfigurationFactory );\n\nfunction AbsyncServiceConfigurationFactory() {\n\treturn AbsyncServiceConfiguration;\n}\n\n/**\n * Configuration for an absync service.\n * Using this type is entirely optional. Providing a hash with the same configuration options will work just fine.\n * @param {Object|String} model Reference to a constructor for the model type, or it's name.\n * If a name is given, absync will try to retrieve instances of the type through injection.\n * @param {String} collectionUri The REST API URI where the collection can be found.\n * Must not end with /\n * @param {String} entityUri The REST API URI where single entities out of the collection can be found.\n * Must not end with /\n * @param {String} [collectionName] The name of the collection. Uses the model name suffixed with \"s\" by default.\n * Using the default value is not recommended.\n * @param {String} [entityName] The name of an entity. Uses the model name by default.\n * Using the default value is not recommended.\n * @param {Function} [deserialize] A function that takes an object received from the server and turns it into a model.\n * By default, absync will just store the raw object without extending it to the model type.\n * Deserializers operate on the actual data received from the websocket.\n * @param {Function} [serialize] A function that takes a model and turns it into something the server expects.\n * By default, absync will just send the complete model.\n * Serializers operate on a copy of the actual model, which already had complex members reduced to their IDs.\n * @param {Function} [injector] An injector to use for model instantiation. Uses $injector by default.\n * Usually, you don't need to provide an alternative here.\n * @param {Boolean} [debug=false] Should additional debugging output be enabled?\n * @param {Object} [allowBrowserCache] A hash that controls the browsing caching behavior.\n * @constructor\n */\nfunction AbsyncServiceConfiguration( model, collectionUri, entityUri, collectionName, entityName, deserialize, serialize, injector, debug, allowBrowserCache ) {\n\tthis.model         = model;\n\tthis.collectionUri = collectionUri;\n\tthis.entityUri     = entityUri;\n\n\tvar _modelName      = model.prototype.constructor.name.toLowerCase();\n\tthis.collectionName = collectionName || ( _modelName + \"s\" );\n\tthis.entityName     = entityName || _modelName;\n\n\tthis.deserialize = deserialize || undefined;\n\tthis.serialize   = serialize || undefined;\n\n\tthis.injector = injector || undefined;\n\n\tthis.debug = debug || false;\n\n\tthis.allowBrowserCache = angular.merge( {}, {\n\t\tsync    : true,\n\t\trequest : true\n\t}, allowBrowserCache );\n}\n}());;(function() {\n\"use strict\";\n/* globals angular */\n\nangular\n\t.module( \"absync\" )\n\t.constant( \"absyncNoopLog\", {\n\t\tdebug : angular.noop,\n\t\tinfo  : angular.noop,\n\t\twarn  : angular.noop,\n\t\terror : angular.noop\n\t} );\n}());;(function() {\n\"use strict\";\n/* globals angular */\n\nangular\n\t.module( \"absync\" )\n\t.filter( \"absyncUncached\", uncachedFilterProvider );\n\nfunction uncachedFilterProvider() {\n\treturn uncachedFilter;\n\n\tfunction uncachedFilter( url ) {\n\t\tif( !url ) {\n\t\t\treturn url;\n\t\t}\n\n\t\tvar delimiter     = -1 < url.indexOf( \"?\" ) ? \"&\" : \"?\";\n\t\tvar discriminator = new Date().getTime();\n\n\t\treturn url + delimiter + \"t=\" + discriminator;\n\t}\n}\n}());","(function() {\n\"use strict\";\n/* globals angular */\n\n/**\n * Please make note of the following conventions:\n * 1. Function-scope local variables must be prefixed with a single underscore.\n *    This indicates a temporary variable.\n * 2. Private variables that are persisted onto publicly accessible entities must be prefixed with two underscores.\n *    This indicates a publicly visible, private variable.\n *    Hiding private variables, by using closures, is discouraged.\n *    Modifying these values from outside of absync is discouraged, but should be respected whenever possible.\n */\n\nangular\n\t.module( \"absync\" )\n\t.constant( \"absyncCache\", getServiceConstructor );\n\n/**\n * A closure to make the configuration available to the cache service.\n * @param {String} name The name of the service.\n * @param {AbsyncServiceConfiguration} configuration The configuration for this service.\n * @returns {CacheService}\n */\nfunction getServiceConstructor( name, configuration ) {\n\t// There is no code here, other than the CacheService definition, followed by \"return CacheService;\"\n\n\t/**\n\t * This service factory is the core of absync.\n\t * It returns a CacheService instance that is specialized to the given configuration.\n\t * This service will handle keep the stored collection in sync.\n\t * @param {angular.IHttpService|Object} $http\n\t * @param {angular.auto.IInjectorService|Object} $injector\n\t * @param {angular.ILogService|Object} $log\n\t * @param {angular.IQService|Object} $q\n\t * @param {angular.IRootScopeService|Object} $rootScope\n\t * @param {AbsyncProvider} absync\n\t * @param {Object} absyncNoopLog A log interface that does nothing.\n\t * @param {Object} absyncUncachedFilter A filter that mutates URLs so they will bypass the browser cache.\n\t * @returns {CacheService}\n\t * @ngInject\n\t */\n\tfunction CacheService( $http, $injector, $log, $q, $rootScope, absync, absyncNoopLog, absyncUncachedFilter ) {\n\t\tvar self = this;\n\n\t\t// Retrieve a reference to the model of the collection that is being cached.\n\t\tvar _injector         = configuration.injector || $injector;\n\t\tvar _injectorHasModel = _injector.has( configuration.model );\n\t\tif( !_injectorHasModel ) {\n\t\t\tthrow new Error( \"Unable to construct the '\" + name + \"' service, because the referenced model '\" + configuration.model + \"' is not available for injection.\" );\n\t\t}\n\t\tvar _model = ( typeof configuration.model === \"string\" ) ? _injector.get( configuration.model ) : configuration.model;\n\n\t\t// Retrieve the serialization methods.\n\t\tvar serializeModel   = _model.serialize || configuration.serialize || serializationNoop;\n\t\tvar deserializeModel = _model.deserialize || configuration.deserialize || serializationNoop;\n\n\t\t// Store configuration.\n\t\tself.name          = name;\n\t\tself.configuration = configuration;\n\n\t\t// The entity cache must be constructed as an empty array or object, to allow the user to place watchers on it.\n\t\t// We must never replace the cache with a new array or object, we must always manipulate the existing one.\n\t\t// Otherwise watchers will not behave as the user expects them to.\n\t\t/* @type {Array<configuration.model>|configuration.model} */\n\t\tself.entityCache          = configuration.collectionName ? [] : {};\n\t\t// Create the ID -> entityIndex lookup table.\n\t\tself.entityCache.__lookup = {};\n\t\t// The raw cache is data that hasn't been deserialized and is used internally.\n\t\tself.__entityCacheRaw     = null;\n\n\t\t// Should request caching be used at all?\n\t\tself.enableRequestCache = true;\n\t\t// Cache requests made to the backend to avoid multiple, simultaneous requests for the same resource.\n\t\tself.__requestCache     = {};\n\t\t// When we make HTTP requests, the browser is generally allowed to cache the responses.\n\t\t// The server can control this behavior with cache control HTTPS headers.\n\t\t// However, at times it may be desirable to force the browser to always fetch fresh data from the backend.\n\t\t// This hash controls this behavior.\n\t\tself.allowBrowserCache = ( angular.merge || angular.extend )( {}, {\n\t\t\t// Should browser caching be allowed for initial cache sync operations?\n\t\t\tsync    : true,\n\t\t\t// Should browser caching be allowed when we retrieve single entities from the backend?\n\t\t\trequest : true\n\t\t}, configuration.allowBrowserCache );\n\t\tself.__uncached        = absyncUncachedFilter;\n\n\t\t// Use $http by default and expose it on the service.\n\t\t// This allows the user to set a different, possibly decorated, HTTP interface for this service.\n\t\tself.httpInterface = $http;\n\t\t// Do the same for our logger.\n\t\tself.logInterface  = configuration.debug ? $log : absyncNoopLog;\n\t\t// The scope on which we broadcast all our relevant events.\n\t\tself.scope         = configuration.scope || $rootScope;\n\t\t// Keep a reference to $q.\n\t\tself.q             = $q;\n\t\t// Keep a reference to absync itself.\n\t\tself.absync        = absync;\n\n\t\t// Prefix log messages with this string.\n\t\tself.logPrefix = \"absync:\" + name.toLocaleUpperCase() + \" \";\n\n\t\t// If enabled, entities received in response to a create or update API call, will be put into the cache.\n\t\t// Otherwise, absync will wait for them to be published through the websocket channel.\n\t\tself.forceEarlyCacheUpdate = configuration.forceEarlyCacheUpdate || false;\n\n\t\t// Throws failures so that they can be handled outside of absync.\n\t\tself.throwFailures = typeof configuration.throwFailures !== \"undefined\" ? configuration.throwFailures : true;\n\n\t\t// Expose the serializer/deserializer so that they can be adjusted at any time.\n\t\tself.serializer   = serializeModel;\n\t\tself.deserializer = deserializeModel;\n\n\t\t// Store a reference to the optional filter function.\n\t\tself.filter = configuration.filter;\n\n\t\t// Bind event handlers to this cache service, to ensure consistent this binding.\n\t\tself.__onEntityOnWebsocketBound     = self.__onEntityOnWebsocket.bind( self );\n\t\tself.__onCollectionOnWebsocketBound = self.__onCollectionOnWebsocket.bind( self );\n\t\tself.__onEntityReceivedBound        = self.__onEntityReceived.bind( self );\n\t\tself.__onCollectionReceivedBound    = self.__onCollectionReceived.bind( self );\n\n\t\t// Tell absync to register an event listener for both our entity and its collection.\n\t\t// When we receive these events, we broadcast an equal Angular event on the root scope.\n\t\t// This way the user can already peek at the data (manipulating it is discouraged though).\n\t\tabsync.on( configuration.entityName, self.__onEntityOnWebsocketBound );\n\t\tif( configuration.collectionName ) {\n\t\t\tabsync.on( configuration.collectionName, self.__onCollectionOnWebsocketBound );\n\t\t}\n\n\t\t// Now we listen on the root scope for the same events we're firing above.\n\t\t// This is where our own absync synchronization logic kicks in.\n\t\tself.__onEntityReceivedBound.unregister = self.scope.$on( configuration.entityName,\n\t\t\tself.__onEntityReceivedBound );\n\t\tif( configuration.collectionName ) {\n\t\t\tself.__onCollectionReceivedBound.unregister = self.scope.$on( configuration.collectionName,\n\t\t\t\tself.__onCollectionReceivedBound );\n\t\t}\n\n\t\tself.logInterface.info( self.logPrefix + \"service was instantiated.\" );\n\t}\n\n\t/**\n\t * Invoked when an entity is received on a websocket.\n\t * Translates the websocket event to an Angular event and broadcasts it on the scope.\n\t * @param {Object} message\n\t * @private\n\t */\n\tCacheService.prototype.__onEntityOnWebsocket = function CacheService$onEntityOnWebsocket( message ) {\n\t\tvar self = this;\n\t\tself.logInterface.debug( self.logPrefix + \"entity received\", message );\n\t\tself.scope.$broadcast( configuration.entityName, message[ configuration.entityName ] );\n\t};\n\n\t/**\n\t * Invoked when a collection is received on a websocket.\n\t * Translates the websocket event to an Angular event and broadcasts it on the scope.\n\t * @param {Object} message\n\t * @private\n\t */\n\tCacheService.prototype.__onCollectionOnWebsocket = function CacheService$onCollectionOnWebsocket( message ) {\n\t\tvar self = this;\n\t\tself.logInterface.debug( self.logPrefix + \"collection received\", message );\n\t\tself.scope.$broadcast( configuration.collectionName, message[ configuration.collectionName ] );\n\t};\n\n\t/**\n\t * Event handler for when the initial badge of raw data becomes available.\n\t * @param {Array<Object>|Object} rawData\n\t * @private\n\t */\n\tCacheService.prototype.__onDataAvailable = function CacheService$onDataAvailable( rawData ) {\n\t\tvar self = this;\n\n\t\tif( Array.isArray( self.entityCache ) ) {\n\t\t\t// The symbol self.entityCache is expected to be an empty array.\n\t\t\t// We initialize it in the constructor to an empty array and we don't expect any writes to have\n\t\t\t// happened to it. In case writes *did* happen, we assume that whoever wrote to it knows what\n\t\t\t// they're doing.\n\t\t\tangular.forEach( rawData[ configuration.collectionName ], deserializeCollectionEntry );\n\n\t\t\t// Notify the rest of the application about a fresh collection.\n\t\t\tself.scope.$broadcast( \"collectionNew\", {\n\t\t\t\tservice : self,\n\t\t\t\tcache   : self.entityCache\n\t\t\t} );\n\n\t\t} else {\n\t\t\tvar deserialized = self.deserializer( rawData[ configuration.entityName ] );\n\t\t\tself.__updateCacheWithEntity( deserialized );\n\t\t}\n\n\t\treturn self.entityCache;\n\n\t\tfunction deserializeCollectionEntry( rawEntity ) {\n\t\t\tvar entityToCache = self.deserializer( rawEntity );\n\t\t\tself.entityCache.push( entityToCache );\n\t\t\tif( self.entityCache.__lookup ) {\n\t\t\t\tself.entityCache.__lookup[ entityToCache.id ] = self.entityCache.length - 1;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Event handler for when an entity is received on the root scope.\n\t * @param {Object} event The event object.\n\t * @param {Object} args The raw object as it was read from the wire.\n\t * @return {Promise|undefined}\n\t * @private\n\t */\n\tCacheService.prototype.__onEntityReceived = function CacheService$onEntityReceived( event, args ) {\n\t\tvar self            = this;\n\t\tvar _entityReceived = args;\n\n\t\t// Sometimes you don't want to use an entity cache, and only listen to websocket events.\n\t\t// In this case you don't configure an entityUri and entityUri, so received entities will be emitted directly.\n\t\tif( configuration.collectionUri === null && configuration.entityUri === null ) {\n\n\t\t\tvar directResponse = {\n\t\t\t\tservice : self,\n\t\t\t\tcache   : self.entityCache,\n\t\t\t\tentity  : _entityReceived\n\t\t\t};\n\n\t\t\tself.scope.$broadcast( \"beforeEntityNew\", directResponse );\n\t\t\tself.scope.$broadcast( \"entityNew\", directResponse );\n\n\t\t\t//noinspection JSValidateTypes\n\t\t\treturn self.q.when();\n\t\t}\n\n\t\t// Check if our raw entity cache was even initialized.\n\t\t// It's possible that it isn't, because websocket updates can be received before any manual requests\n\t\t// were made to the backend.\n\t\tif( !self.__entityCacheRaw || !self.__entityCacheRaw[ configuration.collectionName || configuration.entityName ] ) {\n\t\t\t// We ignore this update and just stack a new read request on top of any existing ones.\n\t\t\t// This makes sure that we load the freshest entity in an orderly fashion and lose the state we received\n\t\t\t// here, as we're getting the latest version of the entity.\n\t\t\treturn self.ensureLoaded()\n\t\t\t\t.then( function updateEntity() {\n\t\t\t\t\treturn self.read( _entityReceived.id );\n\t\t\t\t} );\n\t\t}\n\n\t\t// Determine if the received record consists ONLY of an id property,\n\t\t// which would mean that this record was deleted from the backend.\n\t\tif( 1 === Object.keys( _entityReceived ).length && _entityReceived.hasOwnProperty( \"id\" ) ) {\n\t\t\tself.logInterface.info( self.logPrefix + \"Entity was deleted from the server. Updating cache…\" );\n\n\t\t\tself.__cacheMaintain( self.__entityCacheRaw[ configuration.collectionName || configuration.entityName ],\n\t\t\t\t_entityReceived,\n\t\t\t\t\"delete\",\n\t\t\t\tfalse );\n\n\t\t\treturn self.__removeEntityFromCache( _entityReceived.id );\n\n\t\t} else {\n\t\t\tself.logInterface.debug( self.logPrefix + \"Entity was updated on the server. Updating cache…\" );\n\n\t\t\tself.__cacheMaintain( self.__entityCacheRaw[ configuration.collectionName || configuration.entityName ],\n\t\t\t\t_entityReceived,\n\t\t\t\t\"update\",\n\t\t\t\tfalse );\n\n\t\t\treturn self.__updateCacheWithEntity( self.deserializer( _entityReceived ) );\n\t\t}\n\t};\n\n\t/**\n\t * Event handler for when a collection is received on the root scope.\n\t * @param {Object} event The event object.\n\t * @param {Array<Object>} args The raw collection as it was read from the wire.\n\t * @private\n\t */\n\tCacheService.prototype.__onCollectionReceived = function CacheService$onCollectionReceived( event, args ) {\n\t\tvar self                = this;\n\t\tvar _collectionReceived = args;\n\n\t\t// When we're receiving a full collection, all data we currently have in our cache is useless.\n\t\t// We reset the length of the array here, because assigning a new array would possibly conflict\n\t\t// with watchers placed on the original object.\n\t\tself.entityCache.length = 0;\n\n\t\t// Deserialize the received data and place the models in our cache.\n\t\tangular.forEach( _collectionReceived, addEntityToCache );\n\n\t\tfunction addEntityToCache( entityReceived ) {\n\t\t\tvar deserialized = self.deserializer( entityReceived );\n\t\t\tself.__updateCacheWithEntity( deserialized );\n\t\t}\n\t};\n\n\t/**\n\t * Ensure that the cached collection is retrieved from the server.\n\t * @param {Boolean} [forceReload=false] Should the data be loaded, even if the service already has a local cache?\n\t * @returns {Promise<Array<configuration.model>>|IPromise<Array>|IPromise<void>|Q.Promise<Array<configuration.model>>|angular.IPromise<TResult>}\n\t */\n\tCacheService.prototype.ensureLoaded = function CacheService$ensureLoaded( forceReload ) {\n\t\tvar self = this;\n\n\t\tforceReload = forceReload === true;\n\t\tif( forceReload ) {\n\t\t\tdelete self.__loading;\n\t\t}\n\n\t\tif( self.__loading ) {\n\t\t\treturn self.__loading;\n\t\t}\n\n\t\t// We only perform any loading, if we don't have raw data cached yet, or if we're forced.\n\t\tif( null === self.__entityCacheRaw || forceReload ) {\n\t\t\tif( !configuration.collectionName || !configuration.collectionUri ) {\n\t\t\t\tif( configuration.entityName && configuration.entityUri ) {\n\t\t\t\t\tself.__loading = self.httpInterface\n\t\t\t\t\t\t.get( self.allowBrowserCache.sync ? configuration.entityUri : self.__uncached(\n\t\t\t\t\t\t\tconfiguration.entityUri ) )\n\t\t\t\t\t\t.then( onSingleEntityReceived, onSingleEntityRetrievalFailure );\n\n\t\t\t\t} else {\n\t\t\t\t\t// If the user did not provide information necessary to work with a collection, immediately return\n\t\t\t\t\t// a promise for an empty collection. The user could still use read() to grab individual entities.\n\t\t\t\t\treturn self.q.when( [] );\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tself.logInterface.info( self.logPrefix + \"Retrieving '\" + configuration.collectionName + \"' collection…\" );\n\t\t\t\tself.__loading = self.httpInterface\n\t\t\t\t\t.get( self.allowBrowserCache.sync ? configuration.collectionUri : self.__uncached(\n\t\t\t\t\t\tconfiguration.collectionUri ) )\n\t\t\t\t\t.then( onCollectionReceived, onCollectionRetrievalFailure );\n\t\t\t}\n\n\t\t\treturn self.__loading;\n\t\t}\n\n\t\treturn self.q.when( self.entityCache );\n\n\t\t/**\n\t\t * Invoked when the collection was received from the server.\n\t\t * @param {angular.IHttpPromiseCallbackArg|Object} serverResponse The reply sent from the server.\n\t\t */\n\t\tfunction onCollectionReceived( serverResponse ) {\n\t\t\tif( !serverResponse.data[ configuration.collectionName ] ) {\n\t\t\t\tthrow new Error( \"The response from the server was not in the expected format. It should have a member named '\" + configuration.collectionName + \"'.\" );\n\t\t\t}\n\n\t\t\tself.__entityCacheRaw = serverResponse.data;\n\t\t\tself.entityCache.splice( 0, self.entityCache.length );\n\t\t\treturn self.__onDataAvailable( serverResponse.data );\n\t\t}\n\n\t\t/**\n\t\t * Invoked when there was an error while trying to retrieve the collection from the server.\n\t\t * @param {angular.IHttpPromiseCallbackArg|Object} serverResponse The reply sent from the server.\n\t\t */\n\t\tfunction onCollectionRetrievalFailure( serverResponse ) {\n\t\t\tself.logInterface.error( self.logPrefix + \"Unable to retrieve the collection from the server.\",\n\t\t\t\tserverResponse );\n\t\t\tself.__entityCacheRaw = null;\n\n\t\t\tself.scope.$emit( \"absyncError\", serverResponse );\n\n\t\t\tif( self.throwFailures ) {\n\t\t\t\tthrow serverResponse;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Invoked when the entity was received from the server.\n\t\t * @param {angular.IHttpPromiseCallbackArg|Object} serverResponse The reply sent from the server.\n\t\t */\n\t\tfunction onSingleEntityReceived( serverResponse ) {\n\t\t\tif( !serverResponse.data[ configuration.entityName ] ) {\n\t\t\t\tthrow new Error( \"The response from the server was not in the expected format. It should have a member named '\" + configuration.entityName + \"'.\" );\n\t\t\t}\n\n\t\t\tself.__entityCacheRaw = serverResponse.data;\n\t\t\tself.__onDataAvailable( serverResponse.data );\n\t\t}\n\n\t\t/**\n\t\t * Invoked when there was an error while trying to retrieve the entity from the server.\n\t\t * @param {angular.IHttpPromiseCallbackArg|Object} serverResponse The reply sent from the server.\n\t\t */\n\t\tfunction onSingleEntityRetrievalFailure( serverResponse ) {\n\t\t\tself.logInterface.error( self.logPrefix + \"Unable to retrieve the entity from the server.\",\n\t\t\t\tserverResponse );\n\t\t\tself.__entityCacheRaw = null;\n\n\t\t\tself.scope.$emit( \"absyncError\", serverResponse );\n\n\t\t\tif( self.throwFailures ) {\n\t\t\t\tthrow serverResponse;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Pre-seed the cache with the given value.\n\t * Usually, you'd want to follow this up with a sync() to get fully in sync with the backend.\n\t * @param {Object|Array<Object>} cache\n\t * @returns {CacheService}\n\t */\n\tCacheService.prototype.seed = function CacheService$seed( cache ) {\n\t\tvar self              = this;\n\t\tself.__entityCacheRaw = cache;\n\n\t\treturn self.__onDataAvailable( self.__entityCacheRaw );\n\t};\n\n\t/**\n\t * Insert a phantom into the cache, if no real entity with the same ID exists yet.\n\t * Phantoms bypass the raw entity cache.\n\t * @param {Object} entity\n\t * @param {Number} [timeout] How long to wait for the phantom to be replaced.\n\t * If no timeout is defined, the replacement of the phantom is ignored.\n\t * To wait forever for the phantom to be replaced, set `timeout` to Number.POSITIVE_INFINITY or `null`.\n\t * @return {Promise<Object>} Resolved when the phantom is replaced by the actual entity; rejected after the timeout.\n\t */\n\tCacheService.prototype.phantom = function CacheService$phantom( entity, timeout ) {\n\t\tvar self = this;\n\n\t\tif( self.has( entity.id ) ) {\n\t\t\treturn self.read( entity.id );\n\t\t}\n\n\t\ttimeout = timeout === null ? Number.POSITIVE_INFINITY : timeout;\n\t\ttimeout = typeof timeout === \"undefined\" ? null : timeout;\n\n\t\t//noinspection JSValidateTypes\n\t\treturn self.q.when( self.__onEntityReceived( null, entity ) )\n\t\t\t.then( function onPhantomRegistered() {\n\t\t\t\treturn new self.q( function resolver( resolve, reject ) {\n\n\t\t\t\t\tif( timeout === null ) {\n\t\t\t\t\t\t// The user did not want to wait for the replacement.\n\t\t\t\t\t\treturn resolve( entity );\n\t\t\t\t\t}\n\n\t\t\t\t\tvar removeTimeout  = null;\n\t\t\t\t\tvar removeListener = null;\n\n\t\t\t\t\tif( timeout < Number.POSITIVE_INFINITY ) {\n\t\t\t\t\t\tremoveTimeout = setTimeout( function abortWaiting() {\n\t\t\t\t\t\t\tif( removeListener ) {\n\t\t\t\t\t\t\t\tremoveListener();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treject( new Error( \"Phantom was not replaced in time.\" ) );\n\t\t\t\t\t\t}, timeout );\n\t\t\t\t\t}\n\n\t\t\t\t\tremoveListener = self.scope.$on( \"entityUpdated\", function onEntityUpdated( event, args ) {\n\t\t\t\t\t\tif( args.entity.id === entity.id ) {\n\t\t\t\t\t\t\tremoveListener();\n\t\t\t\t\t\t\tclearTimeout( removeTimeout );\n\n\t\t\t\t\t\t\tremoveListener = null;\n\t\t\t\t\t\t\tremoveTimeout  = null;\n\n\t\t\t\t\t\t\tresolve( args.entity );\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\t\t\t} );\n\t\t\t} );\n\t};\n\n\t/**\n\t * Drop existing cache and force reload.\n\t * @returns {Promise.<Array.<configuration.model>>|IPromise.<Array>|IPromise.<void>|Q.Promise.<Array.<configuration.model>>|angular.IPromise.<TResult>}\n\t */\n\tCacheService.prototype.sync = function CacheService$sync() {\n\t\tvar self = this;\n\n\t\tself.__entityCacheRaw = null;\n\n\t\treturn self.ensureLoaded( true );\n\t};\n\n\t/**\n\t * Check if the given element with the given ID is in the cache.\n\t * @param {String} id\n\t * @return {Boolean} true if the element is in the cache; false otherwise.\n\t */\n\tCacheService.prototype.has = function CacheService$has( id ) {\n\t\tvar self = this;\n\n\t\treturn self.entityCache.__lookup.hasOwnProperty( id );\n\t};\n\n\t/**\n\t * Read a single entity from the cache, or load it from the server if required.\n\t * The entity will be placed into the cache.\n\t * @param {String} id The ID of the entity to retrieve.\n\t * @param {Boolean} [forceReload=false] Should the entity be retrieved from the server, even if it is already in the cache?\n\t * @returns {Promise<configuration.model>|IPromise<TResult>|IPromise<void>|angular.IPromise<TResult>}\n\t */\n\tCacheService.prototype.read = function CacheService$read( id, forceReload ) {\n\t\tvar self = this;\n\n\t\tforceReload = forceReload === true;\n\n\t\tself.logInterface.debug( self.logPrefix + \"Requesting entity '\" + id + \"' (forceReload:\" + forceReload + \")…\" );\n\n\t\tif( !forceReload ) {\n\t\t\tvar entityIndex = 0;\n\n\t\t\t// Check if the entity is in the cache and return instantly if found.\n\t\t\tif( self.entityCache.__lookup ) {\n\t\t\t\tentityIndex = self.entityCache.__lookup.hasOwnProperty( id ) ? self.entityCache.__lookup[ id ] : self.entityCache.length;\n\t\t\t}\n\n\t\t\tfor( var entity = self.entityCache[ entityIndex ];\n\t\t\t     entityIndex < self.entityCache.length;\n\t\t\t     ++entityIndex, entity = self.entityCache[ entityIndex ] ) {\n\t\t\t\tif( entity.id === id ) {\n\t\t\t\t\tself.logInterface.debug( self.logPrefix + \"Requested entity  '\" + id + \"' is served from cache.\" );\n\t\t\t\t\treturn self.q.when( entity );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tself.logInterface.debug( self.logPrefix + \"Requested entity  '\" + id + \"' is fetched from backend.\" );\n\n\t\treturn self.__requestEntity( id )\n\t\t\t.then( onEntityRetrieved, onEntityRetrievalFailure );\n\n\t\t/**\n\t\t * Invoked when the entity was retrieved from the server.\n\t\t * @param {angular.IHttpPromiseCallbackArg|Object} serverResponse The reply sent from the server.\n\t\t */\n\t\tfunction onEntityRetrieved( serverResponse ) {\n\t\t\tif( !serverResponse.data[ configuration.entityName ] ) {\n\t\t\t\tthrow new Error( \"The response from the server was not in the expected format. It should have a member named '\" + configuration.entityName + \"'.\" );\n\t\t\t}\n\n\t\t\tvar rawEntity = serverResponse.data[ configuration.entityName ];\n\n\t\t\t// Put the raw entity into our raw entity cache.\n\t\t\t// We keep the raw copy to allow caching of the raw data.\n\t\t\tself.__cacheMaintain( self.__entityCacheRaw[ configuration.collectionName || configuration.entityName ],\n\t\t\t\trawEntity,\n\t\t\t\t\"update\",\n\t\t\t\tfalse );\n\n\t\t\t// Deserialize the object and place it into the cache.\n\t\t\t// We do not need to check here if the object already exists in the cache.\n\t\t\t// While it could be possible that the same entity is retrieved multiple times, __updateCacheWithEntity\n\t\t\t// will not insert duplicates into the cache.\n\t\t\tvar deserialized = self.deserializer( rawEntity );\n\t\t\tself.__updateCacheWithEntity( deserialized );\n\t\t\treturn deserialized;\n\t\t}\n\n\t\t/**\n\t\t * Invoked when there was an error while trying to retrieve the entity from the server.\n\t\t * @param {angular.IHttpPromiseCallbackArg|Object} serverResponse The reply sent from the server.\n\t\t */\n\t\tfunction onEntityRetrievalFailure( serverResponse ) {\n\t\t\tself.logInterface.error( self.logPrefix + \"Unable to retrieve entity with ID '\" + id + \"' from the server.\",\n\t\t\t\tserverResponse );\n\t\t\tself.scope.$emit( \"absyncError\", serverResponse );\n\n\t\t\tif( self.throwFailures ) {\n\t\t\t\tthrow serverResponse;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Request an entity from the backend.\n\t * @param {String} id The ID of the entity.\n\t * @returns {Promise<configuration.model>|IPromise<TResult>|IPromise<void>|angular.IPromise<TResult>}\n\t * @private\n\t */\n\tCacheService.prototype.__requestEntity = function CacheService$requestEntity( id ) {\n\t\tvar self = this;\n\n\t\tif( self.enableRequestCache && self.__requestCache && self.__requestCache[ id ] ) {\n\t\t\tself.logInterface.debug( self.logPrefix + \"Entity request    '\" + id + \"' served from request cache.\" );\n\t\t\treturn self.__requestCache[ id ];\n\t\t}\n\n\t\t// Make sure our raw entity cache exists.\n\t\tself.__entityCacheRaw                                 = self.__entityCacheRaw || {};\n\t\tself.__entityCacheRaw[ configuration.collectionName ] = self.__entityCacheRaw[ configuration.collectionName ] || [];\n\n\t\tvar requestUri = configuration.entityUri + ( id ? ( \"/\" + id ) : \"\" );\n\n\t\t// Grab the entity from the backend.\n\t\tvar request = self.httpInterface\n\t\t\t.get( self.allowBrowserCache.request ? requestUri : self.__uncached( requestUri ) )\n\t\t\t.then( removeRequestFromCache.bind( self, id ) );\n\n\t\tif( self.enableRequestCache && self.__requestCache ) {\n\t\t\tself.__requestCache[ id ] = request;\n\t\t}\n\n\t\treturn request;\n\n\t\tfunction removeRequestFromCache( id, serverResponse ) {\n\t\t\tdelete self.__requestCache[ id ];\n\t\t\treturn serverResponse;\n\t\t}\n\t};\n\n\t/**\n\t * Updates an entity and persists it to the backend and the cache.\n\t * @param {configuration.model} entity\n\t * @param {Boolean} [returnResult=false] Should the result of the query be returned?\n\t * @return {Promise<configuration.model>|IPromise<TResult>|angular.IPromise<TResult>} A promise that will be resolved with the updated entity.\n\t */\n\tCacheService.prototype.update = function CacheService$update( entity, returnResult ) {\n\t\tvar self = this;\n\n\t\treturnResult = returnResult || false;\n\n\t\t// First create a copy of the object, which has complex properties reduced to their respective IDs.\n\t\tvar reduced    = self.reduceComplex( entity );\n\t\t// Now serialize the object.\n\t\tvar serialized = self.serializer( reduced );\n\n\t\t// Wrap the entity in a new object, with a single property, named after the entity type.\n\t\tvar wrappedEntity                         = {};\n\t\twrappedEntity[ configuration.entityName ] = serialized;\n\n\t\t// Check if the entity has an \"id\" property, if it has, we will update. Otherwise, we create.\n\t\tif( \"undefined\" !== typeof entity.id ) {\n\t\t\treturn self.httpInterface\n\t\t\t\t.put( configuration.entityUri + \"/\" + entity.id, wrappedEntity )\n\t\t\t\t.then( afterEntityStored.bind( self, returnResult ), onEntityStorageFailure.bind( self ) );\n\n\t\t} else {\n\t\t\t// Create a new entity\n\t\t\treturn self.httpInterface\n\t\t\t\t.post( configuration.collectionUri, wrappedEntity )\n\t\t\t\t.then( afterEntityStored.bind( self, returnResult ), onEntityStorageFailure.bind( self ) );\n\t\t}\n\t};\n\n\tCacheService.prototype.patch = function CacheService$patch( entity, returnResult ) {\n\t\tvar self = this;\n\n\t\treturnResult = returnResult || false;\n\n\t\t// First create a copy of the object, which has complex properties reduced to their respective IDs.\n\t\tvar reduced    = self.reduceComplex( entity );\n\t\t// Now serialize the object.\n\t\tvar serialized = self.serializer( reduced );\n\n\t\t// Wrap the entity in a new object, with a single property, named after the entity type.\n\t\tvar wrappedEntity                         = {};\n\t\twrappedEntity[ configuration.entityName ] = serialized;\n\n\t\t// Check if the entity has an \"id\" property, if it has, we will update. Otherwise, we create.\n\t\tif( \"undefined\" !== typeof entity.id ) {\n\t\t\treturn self.httpInterface\n\t\t\t\t.patch( configuration.entityUri + \"/\" + entity.id, wrappedEntity )\n\t\t\t\t.then( afterEntityStored.bind( self, returnResult ), onEntityStorageFailure.bind( self ) );\n\n\t\t} else {\n\t\t\tthrow new Error( \"Attempted to patch an entity that was never stored on the server.\" );\n\t\t}\n\t};\n\n\t/**\n\t * Creates a new entity and persists it to the backend and the cache.\n\t */\n\tCacheService.prototype.create = CacheService.prototype.update;\n\n\t/**\n\t * Invoked when the entity was stored on the server.\n\t * @param {Boolean} returnResult Should we return the parsed entity that is contained in the response?\n\t * @param {angular.IHttpPromiseCallbackArg|Object} serverResponse The reply sent from the server.\n\t */\n\tfunction afterEntityStored( returnResult, serverResponse ) {\n\t\tvar self = this;\n\n\t\t// Writing an entity to the backend will usually invoke an update event to be\n\t\t// broadcast over websockets, where we would also retrieve the updated record.\n\t\t// We still put the updated record we receive here into the cache to ensure early consistency, if that is requested.\n\t\tif( !returnResult && !self.forceEarlyCacheUpdate ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif( serverResponse.data[ configuration.entityName ] ) {\n\t\t\tvar rawEntity = serverResponse.data[ configuration.entityName ];\n\t\t\t// If early cache updates are forced, put the return entity into the cache.\n\t\t\tif( self.forceEarlyCacheUpdate ) {\n\t\t\t\tvar newEntity = self.deserializer( rawEntity );\n\t\t\t\tself.__updateCacheWithEntity( newEntity );\n\n\t\t\t\tif( returnResult ) {\n\t\t\t\t\treturn newEntity;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( returnResult ) {\n\t\t\t\treturn rawEntity;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Invoked when there was an error while trying to store the entity on the server.\n\t * @param {angular.IHttpPromiseCallbackArg|Object} serverResponse The reply sent from the server.\n\t */\n\tfunction onEntityStorageFailure( serverResponse ) {\n\t\tvar self = this;\n\n\t\tself.logInterface.error( self.logPrefix + \"Unable to store entity on the server.\",\n\t\t\tserverResponse );\n\t\tself.logInterface.error( serverResponse );\n\t\tself.scope.$emit( \"absyncError\", serverResponse );\n\n\t\tif( self.throwFailures ) {\n\t\t\tthrow serverResponse;\n\t\t}\n\t}\n\n\t/**\n\t * Remove an entity from the cache and have it deleted on the backend.\n\t * @param {Object} entity\n\t */\n\tCacheService.prototype.delete = function CacheService$delete( entity ) {\n\t\tvar self = this;\n\n\t\tvar entityId = entity.id;\n\t\treturn self.httpInterface\n\t\t\t.delete( configuration.entityUri + \"/\" + entityId )\n\t\t\t.then( onEntityDeleted )\n\t\t\t.catch( onEntityDeletionFailed );\n\n\t\t/**\n\t\t * Invoked when the entity was successfully deleted from the server.\n\t\t * @param {angular.IHttpPromiseCallbackArg|Object} serverResponse The reply sent from the server.\n\t\t */\n\t\tfunction onEntityDeleted( serverResponse ) {\n\t\t\tself.__cacheMaintain( self.__entityCacheRaw[ configuration.collectionName || configuration.entityName ],\n\t\t\t\tentity,\n\t\t\t\t\"delete\",\n\t\t\t\tfalse );\n\n\t\t\treturn self.__removeEntityFromCache( entityId );\n\t\t}\n\n\t\t/**\n\t\t * Invoked when there was an error while trying to delete the entity from the server.\n\t\t * @param {angular.IHttpPromiseCallbackArg|Object} serverResponse The reply sent from the server.\n\t\t */\n\t\tfunction onEntityDeletionFailed( serverResponse ) {\n\t\t\tself.logInterface.error( serverResponse.data );\n\t\t\tself.scope.$emit( \"absyncError\", serverResponse );\n\n\t\t\tif( self.throwFailures ) {\n\t\t\t\tthrow serverResponse;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Put an entity into the cache or update the existing record if the entity was already in the cache.\n\t * @param {Object} entityToCache\n\t * @private\n\t */\n\tCacheService.prototype.__updateCacheWithEntity = function CacheService$updateCacheWithEntity( entityToCache ) {\n\t\tvar self = this;\n\n\t\tself.logInterface.info( self.logPrefix + \"Updating entity '\" + ( entityToCache.id || self.name ) + \"' in cache…\",\n\t\t\tentityToCache );\n\n\t\treturn self.__cacheMaintain( self.entityCache, entityToCache, \"update\", true );\n\t};\n\n\t/**\n\t * Perform maintenance operations on a cache.\n\t * @param cache The cache to operate on.\n\t * @param entityToCache The entity that the operation is relating to.\n\t * @param {String} operation The operation to perform.\n\t * @param {Boolean} [emit=false] Should appropriate absync events be broadcast to notify other actors?\n\t * @private\n\t */\n\tCacheService.prototype.__cacheMaintain = function CacheService$cacheMaintain( cache, entityToCache, operation, emit ) {\n\t\tvar self = this;\n\n\t\tvar entityIndex = 0;\n\t\tvar entity      = cache[ entityIndex ];\n\n\t\tif( self.filter ) {\n\t\t\tif( !self.filter( entityToCache ) ) {\n\t\t\t\tself.logInterface.info( self.logPrefix + \"Entity '\" + ( entityToCache.id || self.name ) + \"' was filtered.\",\n\t\t\t\t\tentityToCache );\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif( cache.__lookup ) {\n\t\t\tentityIndex = cache.__lookup.hasOwnProperty( entityToCache.id ) ? cache.__lookup[ entityToCache.id ] : cache.length;\n\t\t\tentity      = cache[ entityIndex ];\n\t\t}\n\n\t\tswitch( operation ) {\n\t\t\tcase \"update\":\n\t\t\t\tif( !Array.isArray( cache ) ) {\n\t\t\t\t\tif( emit ) {\n\t\t\t\t\t\t// Allow the user to intervene in the update process, before updating the entity.\n\t\t\t\t\t\tself.scope.$broadcast( \"beforeEntityUpdated\",\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tservice : self,\n\t\t\t\t\t\t\t\tcache   : cache,\n\t\t\t\t\t\t\t\tentity  : cache,\n\t\t\t\t\t\t\t\tupdated : entityToCache\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\n\t\t\t\t\tif( typeof cache.copyFrom === \"function\" ) {\n\t\t\t\t\t\tcache.copyFrom( entityToCache );\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tangular.extend( cache, entityToCache );\n\t\t\t\t\t}\n\n\t\t\t\t\t// After updating the entity, send another event to allow the user to react.\n\t\t\t\t\tself.scope.$broadcast( \"entityUpdated\",\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tservice : self,\n\t\t\t\t\t\t\tcache   : cache,\n\t\t\t\t\t\t\tentity  : cache\n\t\t\t\t\t\t} );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar found = false;\n\t\t\t\tfor( angular.noop; entityIndex < cache.length; ++entityIndex, entity = cache[ entityIndex ] ) {\n\t\t\t\t\tif( entity.id === entityToCache.id ) {\n\t\t\t\t\t\tif( emit ) {\n\t\t\t\t\t\t\t// Allow the user to intervene in the update process, before updating the entity.\n\t\t\t\t\t\t\tself.scope.$broadcast( \"beforeEntityUpdated\",\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tservice : self,\n\t\t\t\t\t\t\t\t\tcache   : cache,\n\t\t\t\t\t\t\t\t\tentity  : cache[ entityIndex ],\n\t\t\t\t\t\t\t\t\tupdated : entityToCache\n\t\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Use the \"copyFrom\" method on the entity, if it exists, otherwise use naive approach.\n\t\t\t\t\t\tvar targetEntity = cache[ entityIndex ];\n\t\t\t\t\t\tif( typeof targetEntity.copyFrom === \"function\" ) {\n\t\t\t\t\t\t\ttargetEntity.copyFrom( entityToCache );\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tangular.extend( targetEntity, entityToCache );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfound = true;\n\n\t\t\t\t\t\tif( emit ) {\n\t\t\t\t\t\t\t// After updating the entity, send another event to allow the user to react.\n\t\t\t\t\t\t\tself.scope.$broadcast( \"entityUpdated\",\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tservice : self,\n\t\t\t\t\t\t\t\t\tcache   : cache,\n\t\t\t\t\t\t\t\t\tentity  : cache[ entityIndex ]\n\t\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If the entity wasn't found in our records, it's a new entity.\n\t\t\t\tif( !found ) {\n\t\t\t\t\tif( emit ) {\n\t\t\t\t\t\tself.scope.$broadcast( \"beforeEntityNew\", {\n\t\t\t\t\t\t\tservice : self,\n\t\t\t\t\t\t\tcache   : cache,\n\t\t\t\t\t\t\tentity  : entityToCache\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\n\t\t\t\t\tcache.push( entityToCache );\n\t\t\t\t\tif( cache.__lookup ) {\n\t\t\t\t\t\tcache.__lookup[ entityToCache.id ] = cache.length - 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif( emit ) {\n\t\t\t\t\t\tself.scope.$broadcast( \"entityNew\", {\n\t\t\t\t\t\t\tservice : self,\n\t\t\t\t\t\t\tcache   : cache,\n\t\t\t\t\t\t\tentity  : entityToCache\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"delete\":\n\t\t\t\t// The \"delete\" operation is not expected to happen for single cached entities.\n\t\t\t\tfor( angular.noop; entityIndex < cache.length; ++entityIndex, entity = cache[ entityIndex ] ) {\n\t\t\t\t\tif( entity.id === entityToCache.id ) {\n\t\t\t\t\t\tif( emit ) {\n\t\t\t\t\t\t\t// Before removing the entity, allow the user to react.\n\t\t\t\t\t\t\tself.scope.$broadcast( \"beforeEntityRemoved\", {\n\t\t\t\t\t\t\t\tservice : self,\n\t\t\t\t\t\t\t\tcache   : cache,\n\t\t\t\t\t\t\t\tentity  : entity\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Remove the entity from the cache.\n\t\t\t\t\t\tcache.splice( entityIndex, 1 );\n\n\t\t\t\t\t\tif( cache.__lookup ) {\n\t\t\t\t\t\t\tdelete cache.__lookup[ entityToCache.id ];\n\n\t\t\t\t\t\t\tfor( var cacheEntry in cache.__lookup ) {\n\t\t\t\t\t\t\t\tif( entityIndex <= cache.__lookup[ cacheEntry ] ) {\n\t\t\t\t\t\t\t\t\t--cache.__lookup[ cacheEntry ];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif( emit ) {\n\t\t\t\t\t\t\t// Send another event to allow the user to take note of the removal.\n\t\t\t\t\t\t\tself.scope.$broadcast( \"entityRemoved\", {\n\t\t\t\t\t\t\t\tservice : self,\n\t\t\t\t\t\t\t\tcache   : cache,\n\t\t\t\t\t\t\t\tentity  : entity\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t};\n\n\t/**\n\t * Removes an entity from the internal cache. The entity is not removed from the backend.\n\t * @param {String} id The ID of the entity to remove from the cache.\n\t * @private\n\t */\n\tCacheService.prototype.__removeEntityFromCache = function CacheService$removeEntityFromCache( id ) {\n\t\tvar self = this;\n\n\t\treturn self.__cacheMaintain( self.entityCache, {\n\t\t\tid : id\n\t\t}, \"delete\", true );\n\t};\n\n\t/**\n\t * Retrieve an associative array of all cached entities, which uses the ID of the entity records as the key in the array.\n\t * This is a convenience method that is not utilized internally.\n\t * @returns {Array<configuration.model>}\n\t */\n\tCacheService.prototype.lookupTableById = function CacheService$lookupTableById() {\n\t\tvar self = this;\n\n\t\tvar lookupTable = [];\n\t\tfor( var entityIndex = 0;\n\t\t     entityIndex < self.entityCache.length;\n\t\t     ++entityIndex ) {\n\t\t\tlookupTable[ self.entityCache[ entityIndex ].id ] = self.entityCache[ entityIndex ];\n\t\t}\n\t\treturn lookupTable;\n\t};\n\n\t/**\n\t * Reduce instances of complex types within an entity with their respective IDs.\n\t * Note that no type checks are being performed. Every nested object with an \"id\" property is treated as a complex type.\n\t * @param {Object} entity The entity that should have its complex member reduced.\n\t * @param {Boolean} [arrayInsteadOfObject=false] true if the manipulated entity is an array; false if it's an object.\n\t * @returns {Object|Array} A copy of the input entity, with complex type instances replaced with their respective ID.\n\t */\n\tCacheService.prototype.reduceComplex = function CacheService$reduceComplex( entity, arrayInsteadOfObject ) {\n\t\tvar self = this;\n\n\t\tvar result = arrayInsteadOfObject ? [] : {};\n\t\tfor( var propertyName in entity ) {\n\t\t\tif( !entity.hasOwnProperty( propertyName ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Recurse for nested arrays.\n\t\t\tif( Array.isArray( entity[ propertyName ] ) ) {\n\t\t\t\tresult[ propertyName ] = self.reduceComplex( entity[ propertyName ], true );\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Replace complex type with its ID.\n\t\t\tif( entity[ propertyName ] && entity[ propertyName ].id ) {\n\t\t\t\tresult[ propertyName ] = entity[ propertyName ].id;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Just copy over the plain property.\n\t\t\tresult[ propertyName ] = entity[ propertyName ];\n\t\t}\n\t\treturn result;\n\t};\n\n\t/**\n\t * Populate references to complex types in an instance.\n\t * @param {Object} entity The entity that should be manipulated.\n\t * @param {String} propertyName The name of the property of entity which should be populated.\n\t * @param {CacheService} cache An instance of another caching service that can provide the complex\n\t * type instances which are being referenced in entity.\n\t * @param {Object|Boolean} [options] A hash with options relating to the population process.\n\t * @param {Boolean} [options.force=false] If true, all complex types will be replaced with references to the\n\t * instances in cache; otherwise, only properties that are string representations of complex type IDs will be replaced.\n\t * @param {Boolean} [options.crossLink=false] If true, the entity will also be put into a relating property in the\n\t * foreign entity.\n\t * @param {String} [options.crossLinkProperty] The name of the property in the foreign type into which the entity\n\t * should be cross-linked.\n\t * @returns {IPromise<TResult>|IPromise<any[]>|IPromise<{}>|angular.IPromise<TResult>}\n\t */\n\tCacheService.prototype.populateComplex = function CacheService$populateComplex( entity, propertyName, cache, options ) {\n\t\tvar self = this;\n\n\t\toptions = options || {};\n\t\tif( typeof options === \"boolean\" ) {\n\t\t\tself.logInterface.warn( \"Argument 'force' is deprecated. Provide an options hash instead.\" );\n\t\t\toptions = {\n\t\t\t\tforce : options\n\t\t\t};\n\t\t}\n\t\toptions.force             = options.force || false;\n\t\toptions.crossLink         = options.crossLink || false;\n\t\toptions.crossLinkProperty = options.crossLinkProperty || \"\";\n\n\t\tif( options.crossLink && !options.crossLinkProperty ) {\n\t\t\tself.logInterface.warn(\n\t\t\t\t\"Option 'crossLink' given without 'crossLinkProperty'. Cross-linking will be disabled.\" );\n\t\t\toptions.crossLink = false;\n\t\t}\n\n\t\t// If the target property is an array, ...\n\t\tif( Array.isArray( entity[ propertyName ] ) ) {\n\t\t\t// ...map the elements in the array to promises.\n\t\t\tvar promises = entity[ propertyName ].map( mapElementToPromise );\n\n\t\t\treturn self.q.all( promises );\n\n\t\t} else {\n\t\t\tif( entity[ propertyName ] === null ) {\n\t\t\t\treturn self.q.when( null )\n\t\t\t\t\t.then( onComplexRetrieved );\n\t\t\t}\n\n\t\t\t// We usually assume the properties to be strings (the ID of the referenced complex).\n\t\t\tif( typeof entity[ propertyName ] !== \"string\" ) {\n\t\t\t\t// If \"force\" is enabled, we check if this non-string property is an object and has an \"id\" member, which is a string.\n\t\t\t\tif( options.force && typeof entity[ propertyName ] === \"object\" && typeof entity[ propertyName ].id === \"string\" ) {\n\t\t\t\t\t// If that is true, then we replace the whole object with the ID and continue as usual.\n\t\t\t\t\tentity[ propertyName ] = entity[ propertyName ].id;\n\n\t\t\t\t} else {\n\t\t\t\t\tif( self.throwFailures ) {\n\t\t\t\t\t\tthrow new Error( \"The referenced entity did not have an 'id' property that would be expected.\" );\n\t\t\t\t\t}\n\t\t\t\t\treturn self.q.when( false );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Treat the property as an ID and read the complex with that ID from the cache.\n\t\t\treturn cache.read( entity[ propertyName ] )\n\t\t\t\t.then( onComplexRetrieved );\n\t\t}\n\n\t\tfunction mapElementToPromise( element, index ) {\n\t\t\t// We usually assume the properties to be strings (the ID of the referenced complex).\n\t\t\tif( typeof entity[ propertyName ][ index ] !== \"string\" ) {\n\t\t\t\t// If \"force\" is enabled, we check if this non-string property is an object and has an \"id\" member, which is a string.\n\t\t\t\tif( options.force && typeof entity[ propertyName ][ index ] === \"object\" && typeof entity[ propertyName ][ index ].id === \"string\" ) {\n\t\t\t\t\t// If that is true, then we replace the whole object with the ID and continue as usual.\n\t\t\t\t\tentity[ propertyName ][ index ] = entity[ propertyName ][ index ].id;\n\n\t\t\t\t} else {\n\t\t\t\t\tif( self.throwFailures ) {\n\t\t\t\t\t\tthrow new Error( \"The referenced entity did not have an 'id' property that would be expected.\" );\n\t\t\t\t\t}\n\n\t\t\t\t\treturn self.q.when( false );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Treat the property as an ID and read the complex with that ID from the cache.\n\t\t\treturn cache.read( entity[ propertyName ][ index ] )\n\t\t\t\t.then( onComplexRetrieved );\n\n\t\t\tfunction onComplexRetrieved( complex ) {\n\t\t\t\t// When the complex was retrieved, store it back into the array.\n\t\t\t\tentity[ propertyName ][ index ] = complex;\n\n\t\t\t\tif( options.crossLink ) {\n\t\t\t\t\tcrossLink( complex, entity );\n\t\t\t\t}\n\n\t\t\t\treturn entity;\n\t\t\t}\n\t\t}\n\n\t\tfunction onComplexRetrieved( complex ) {\n\t\t\t// When the complex was retrieved, store it back into the entity.\n\t\t\tentity[ propertyName ] = complex;\n\n\t\t\tif( options.crossLink ) {\n\t\t\t\tcrossLink( complex, entity );\n\t\t\t}\n\n\t\t\treturn entity;\n\t\t}\n\n\t\tfunction crossLink( complex, entity ) {\n\t\t\t// If cross-linking is enabled, put our entity into the foreign complex.\n\t\t\tif( Array.isArray( complex[ options.crossLinkProperty ] ) ) {\n\t\t\t\t// Check if the ID exists in the array.\n\t\t\t\tvar idIndex = complex[ options.crossLinkProperty ].indexOf( entity.id );\n\t\t\t\tif( -1 < idIndex ) {\n\t\t\t\t\t// Replace the ID with the entity.\n\t\t\t\t\tcomplex[ options.crossLinkProperty ][ idIndex ] = entity;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Check if the entity is already linked into the array.\n\t\t\t\tfor( var lookupIndex = 0, lookupEntity = complex[ options.crossLinkProperty ][ 0 ];\n\t\t\t\t     lookupIndex < complex[ options.crossLinkProperty ].length;\n\t\t\t\t     ++lookupIndex, lookupEntity = complex[ options.crossLinkProperty ][ lookupIndex ] ) {\n\t\t\t\t\t// Check if the exact same reference is already within the array.\n\t\t\t\t\tif( lookupEntity === entity ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check if another element with the same ID already exists in the array.\n\t\t\t\t\tif( lookupEntity.id === entity.id ) {\n\t\t\t\t\t\tcomplex[ options.crossLinkProperty ][ lookupIndex ] = entity;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Just push the element into the array.\n\t\t\t\tcomplex[ options.crossLinkProperty ].push( entity );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcomplex[ options.crossLinkProperty ] = entity;\n\t\t}\n\t};\n\n\t/**\n\t * Reset the state of the cache service to when it was first instantiated.\n\t * Assumes that the configuration was not touched.\n\t * This method is primarily targeted at testing, but can be useful in production as well.\n\t */\n\tCacheService.prototype.reset = function CacheService$reset() {\n\t\tvar self = this;\n\n\t\tself.entityCache          = self.configuration.collectionName ? [] : {};\n\t\tself.entityCache.__lookup = self.entityCache.__lookup || {};\n\n\t\tself.__entityCacheRaw = null;\n\t\tself.__requestCache   = {};\n\t};\n\n\tCacheService.prototype.teardown = function CacheService$teardown() {\n\t\tvar self = this;\n\n\t\tself.absync.off( self.__onEntityOnWebsocketBound );\n\t\tself.absync.off( self.__onCollectionOnWebsocketBound );\n\n\t\tif( self.__onEntityReceivedBound.unregister ) {\n\t\t\tself.__onEntityReceivedBound.unregister();\n\t\t}\n\t\tif( self.__onCollectionReceivedBound.unregister ) {\n\t\t\tself.__onCollectionReceivedBound.unregister();\n\t\t}\n\t};\n\n\treturn CacheService;\n}\n\nfunction serializationNoop( model ) {\n\treturn model;\n}\n}());","(function() {\n\"use strict\";\n/* globals angular */\n\nangular\n\t.module( \"absync\" )\n\t.service( \"AbsyncServiceConfiguration\", AbsyncServiceConfigurationFactory );\n\nfunction AbsyncServiceConfigurationFactory() {\n\treturn AbsyncServiceConfiguration;\n}\n\n/**\n * Configuration for an absync service.\n * Using this type is entirely optional. Providing a hash with the same configuration options will work just fine.\n * @param {Object|String} model Reference to a constructor for the model type, or it's name.\n * If a name is given, absync will try to retrieve instances of the type through injection.\n * @param {String} collectionUri The REST API URI where the collection can be found.\n * Must not end with /\n * @param {String} entityUri The REST API URI where single entities out of the collection can be found.\n * Must not end with /\n * @param {String} [collectionName] The name of the collection. Uses the model name suffixed with \"s\" by default.\n * Using the default value is not recommended.\n * @param {String} [entityName] The name of an entity. Uses the model name by default.\n * Using the default value is not recommended.\n * @param {Function} [deserialize] A function that takes an object received from the server and turns it into a model.\n * By default, absync will just store the raw object without extending it to the model type.\n * Deserializers operate on the actual data received from the websocket.\n * @param {Function} [serialize] A function that takes a model and turns it into something the server expects.\n * By default, absync will just send the complete model.\n * Serializers operate on a copy of the actual model, which already had complex members reduced to their IDs.\n * @param {Function} [injector] An injector to use for model instantiation. Uses $injector by default.\n * Usually, you don't need to provide an alternative here.\n * @param {Boolean} [debug=false] Should additional debugging output be enabled?\n * @param {Object} [allowBrowserCache] A hash that controls the browsing caching behavior.\n * @constructor\n */\nfunction AbsyncServiceConfiguration( model, collectionUri, entityUri, collectionName, entityName, deserialize, serialize, injector, debug, allowBrowserCache ) {\n\tthis.model         = model;\n\tthis.collectionUri = collectionUri;\n\tthis.entityUri     = entityUri;\n\n\tvar _modelName      = model.prototype.constructor.name.toLowerCase();\n\tthis.collectionName = collectionName || ( _modelName + \"s\" );\n\tthis.entityName     = entityName || _modelName;\n\n\tthis.deserialize = deserialize || undefined;\n\tthis.serialize   = serialize || undefined;\n\n\tthis.injector = injector || undefined;\n\n\tthis.debug = debug || false;\n\n\tthis.allowBrowserCache = angular.merge( {}, {\n\t\tsync    : true,\n\t\trequest : true\n\t}, allowBrowserCache );\n}\n}());","(function() {\n\"use strict\";\n/* globals angular */\n\nangular\n\t.module( \"absync\" )\n\t.constant( \"absyncNoopLog\", {\n\t\tdebug : angular.noop,\n\t\tinfo  : angular.noop,\n\t\twarn  : angular.noop,\n\t\terror : angular.noop\n\t} );\n}());","(function() {\n\"use strict\";\n/* globals angular */\n\nangular\n\t.module( \"absync\" )\n\t.filter( \"absyncUncached\", uncachedFilterProvider );\n\nfunction uncachedFilterProvider() {\n\treturn uncachedFilter;\n\n\tfunction uncachedFilter( url ) {\n\t\tif( !url ) {\n\t\t\treturn url;\n\t\t}\n\n\t\tvar delimiter     = -1 < url.indexOf( \"?\" ) ? \"&\" : \"?\";\n\t\tvar discriminator = new Date().getTime();\n\n\t\treturn url + delimiter + \"t=\" + discriminator;\n\t}\n}\n}());"],"sourceRoot":"/source/"}